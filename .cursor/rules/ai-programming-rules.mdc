---
alwaysApply: true
description: AI编程规则备忘录 - 核心编程原则和最佳实践
---

**规则制定时间**: 2024年12月29日  
**最后更新**: 2025年7月7日 - 添加第18条测试代码与被测试代码分离原则  
**适用范围**: 🌐 全项目  
**状态**: ✅ 生效
# AI 编程规则备忘录

## 🎯 核心编程原则

### 1. 代码复用优先原则 ♻️
**永远考虑代码复用**: 在编写功能代码之前，先检查系统中是否已有实现，确实没有实现时，再编写新代码

**实施要求：**
- ✅ **先搜索**: 使用 `grep`、`rg` 或搜索功能查找相似实现
- ✅ **先调研**: 检查现有模块、服务、工具函数是否已有相关功能  
- ✅ **先复用**: 优先使用、扩展现有代码，而不是重新实现
- ❌ **避免重复**: 杜绝复制粘贴相似代码，造成维护噩梦

### 2. 模块化设计原则 🏗️
**模块优先**: 编写新代码时，永远要先根据代码功能考虑应该放到哪个模块中，而不是随手向当前模块中一扔

**实施要求：**
- ✅ **功能归类**: 根据功能职责选择正确的模块目录
- ✅ **分层清晰**: Controller → Service → DAO → Model 分层明确
- ✅ **职责单一**: 每个模块只负责特定功能领域
- ❌ **随意放置**: 禁止图方便随手放到当前工作目录

### 3. 严格按设计文档实现 📋
**功能严格按照设计文档的功能点实现**

**实施要求：**
- ✅ **需求对照**: 每个功能必须对应设计文档中的具体需求点
- ✅ **范围控制**: 不得随意添加设计文档外的功能
- ✅ **文档更新**: 如需变更，必须先更新设计文档
- ❌ **随意扩展**: 禁止自行添加"便民"功能

### 4. API接口稳定性 🔒
**已经定义的API接口不能随意变动，如果需要变动，一定需要得到明确的同意后再进行**

**实施要求：**
- ✅ **向后兼容**: 新版本API必须兼容旧版本
- ✅ **版本控制**: 使用版本号管理API变更（v1, v2）
- ✅ **明确授权**: 接口变更必须获得项目负责人明确同意
- ❌ **破坏性修改**: 禁止未经同意修改现有接口签名

### 5. 文档创建限制 📝
**总结内容后，未经过明确的要求，不得自动写md的总结报告文档**

**实施要求：**
- ✅ **按需创建**: 只在明确要求时创建文档
- ✅ **内容精准**: 文档内容必须准确反映实际实现
- ❌ **自动生成**: 禁止未经要求自动创建总结文档

### 6. 前端状态管理规范 🎨
**前端设计，使用store + useHook，在创建新的store和类型前，先检查现有的store是否已经有实现了**

**实施要求：**
- ✅ **复用Store**: 优先使用现有的store和hook
- ✅ **类型检查**: 创建新类型前检查现有类型定义
- ✅ **统一管理**: 使用统一的状态管理模式
- ❌ **重复创建**: 禁止创建功能重复的store或hook

### 7. API调用统一化 🌐
**所有的API调用必须在统一的request文件中，不许不通过request提供的接口，直接调用API**

**实施要求：**
- ✅ **统一入口**: 所有API调用必须通过request模块
- ✅ **标准化**: 使用统一的请求/响应处理
- ✅ **错误处理**: 统一的错误处理和重试机制
- ❌ **直接调用**: 禁止绕过request直接调用API

### 8. 代码唯一性原则 🔄
**一旦发现有重复实现的多套代码，必须清理到只剩一套，保证代码唯一性**

**实施要求：**
- ✅ **及时清理**: 发现重复代码立即清理
- ✅ **功能合并**: 将重复功能合并为单一实现
- ✅ **引用统一**: 所有调用点改为引用统一实现
- ❌ **容忍重复**: 禁止保留功能重复的多套代码

### 9. 数据库变更规范 🗄️
**原有的系统活动补充时：只允许新建数据库表，未经过明确的讨论和允许，不能够修改更不能够删除原来的库表。新建的代码，需要使用原有的JWT认证系统，而不是另建一套**

**实施要求：**
- ✅ **新建优先**: 扩展功能时优先新建表而非修改现有表
- ✅ **认证复用**: 必须使用现有的JWT认证系统
- ✅ **权限确认**: 修改/删除表操作需要明确讨论和授权
- ❌ **擅自修改**: 禁止未经授权修改或删除现有数据库表
- ❌ **重建认证**: 禁止创建新的认证系统

### 10. 回归测试要求 🧪
**每次新增或是修改功能后，需要对相关接口进行一遍回归测试**

**实施要求：**
- ✅ **测试覆盖**: 新功能必须包含完整的测试用例
- ✅ **回归验证**: 修改后必须验证相关功能正常运行
- ✅ **接口测试**: 重点测试API接口的输入输出
- ❌ **跳过测试**: 禁止未经测试直接部署功能变更

### 11. 服务启动管理规范 🚀
**测试启动服务时，总是先查询现有的端口并且关闭相应的进程后再进行启动，避免端口冲突和服务重复运行**

**实施要求：**
- ✅ **端口检查**: 启动前必须检查目标端口是否被占用
- ✅ **进程清理**: 优雅关闭现有进程，强制清理僵尸进程
- ✅ **统一脚本**: 使用项目提供的service-manager.sh统一管理服务
- ✅ **状态验证**: 启动后验证服务是否正常运行和API可访问性
- ❌ **直接启动**: 禁止不检查端口直接启动服务
- ❌ **手动管理**: 禁止手动使用kill命令管理服务进程

### 12. 功能实现唯一性强制原则 ⚡
**同一功能只能有一个实现，一旦发现有两个相同或类似的实现，必须立刻归并成一个，归并的原则是已经验证正常工作的保留**

**实施要求：**
- ✅ **立即归并**: 发现重复实现时必须立即进行代码归并
- ✅ **保留可用**: 归并时保留已验证正常工作的实现版本
- ✅ **全面替换**: 将所有调用点统一指向保留的实现
- ✅ **彻底清理**: 完全删除被归并的重复实现代码
- ❌ **并存容忍**: 严禁两个相同功能的实现同时存在
- ❌ **延后处理**: 禁止发现重复后延后归并处理

### 13. 服务启动编译规范 🔧
**启动服务时必须遵循：先杀死进程 → 重新编译 → 使用启动脚本的标准流程，确保编译文件与启动脚本中的路径一致**

### 14. 测试前清除日志文件 📋
**每次测试前，清除原有的LOG文件，然后记住当前使用的LOG文件名，测试发生错误时，先看LOG文件定位错误，不要乱猜**

**实施要求：**
- ✅ **清除旧日志**: 每次测试前必须删除或清空原有的日志文件
- ✅ **记录日志名**: 明确知道当前使用的日志文件名称和路径
- ✅ **日志优先**: 测试出错时优先查看日志文件，而不是凭空猜测
- ✅ **精确定位**: 通过日志内容准确定位问题发生的位置和原因
- ❌ **盲目猜测**: 禁止不看日志就随意猜测错误原因
- ❌ **日志混淆**: 禁止在混合了新旧日志的文件中查找问题

### 15. 总结结果输出控制 📝
**总结结果默认控制台输出，只有在有明确指令的情况下，才输出成md文档**

**实施要求：**
- ✅ **默认控制台**: 分析、总结、报告等结果默认在控制台输出
- ✅ **明确指令**: 只有用户明确要求创建md文档时，才创建文件
- ✅ **简洁输出**: 控制台输出应简洁明了，重点突出
- ❌ **自动创建**: 禁止在没有明确要求时自动创建md总结文档
- ❌ **冗余文档**: 禁止为每个分析都创建对应的md文件

### 16. 区块链数字类型处理规范 🔢
**区块链中的数字，在Rust中使用U256，在JavaScript中使用BigInt，在接口中使用字符串**

**实施要求：**
- ✅ **Rust使用U256**: 所有区块链金额、哈希值等大数字在Rust中使用U256或[u8; 32]
- ✅ **JavaScript使用BigInt**: 前端处理大数字时使用BigInt，避免精度丢失
- ✅ **接口使用字符串**: API接口中的大数字字段统一使用字符串格式传输
- ✅ **类型转换**: 实现各类型间的安全转换函数
- ❌ **使用u64**: 禁止在区块链金额处理中使用u64（限制18.4 ETH）
- ❌ **使用number**: 禁止在JavaScript中使用number处理大数字
- ❌ **数值接口**: 禁止在API接口中使用数值类型传输大数字

### 17. 版本升级规则 🔄
**一个功能版本升级后（无论是完善还是安全增强），必须删除原来的版本，只保留最新版本的代码**

**实施要求：**
- ✅ **删除旧版本**: 功能升级后，必须删除所有旧版本的实现代码
- ✅ **保留最新版**: 只保留最新、最安全、最完善的版本
- ✅ **统一接口**: 确保所有调用方都使用最新版本的接口
- ✅ **测试覆盖**: 确保新版本有完整的测试覆盖
- ✅ **文档更新**: 更新相关文档，移除旧版本的引用
- ❌ **保留Legacy**: 禁止为了"兼容性"而保留不安全的旧版本
- ❌ **版本混乱**: 禁止同时存在多个版本造成调用混乱
- ❌ **安全风险**: 禁止保留存在安全风险的旧版本代码

### 18. 测试代码与被测试代码分离原则 🚨⚠️ **极其重要** ⚠️🚨
**添加测试代码时，决不能够因为测试代码没有通过而修改被测试的代码。如果被测试的代码确实有问题，一定要经过明确的交互确认后才可以修改。**

**实施要求：**
- ✅ **测试优先**: 测试失败时，首先检查测试代码本身是否有问题
- ✅ **保护被测代码**: 绝对禁止为了让测试通过而随意修改被测试代码
- ✅ **交互确认**: 只有在确认测试代码正确且被测试代码确实有问题时，才可以请求修改被测试代码
- ✅ **用户授权**: 修改被测试代码必须经过用户的明确交互确认
- ✅ **影响评估**: 修改被测试代码前必须评估对其他功能的影响
- ❌ **盲目修改**: 严禁因为测试不通过就直接修改被测试代码
- ❌ **绕过确认**: 严禁在没有用户确认的情况下修改核心功能代码

### 19. 编译清理优化原则 🚀
**避免不必要的clean操作，节省编译时间**

**实施要求：**
- ✅ **避免盲目clean**: 除非有明确的编译问题或依赖冲突，否则不需要每次编译前都执行clean操作
- ✅ **特殊环境考虑**: 特别是在ZKVM等复杂编译环境中，编译时间极长，clean操作代价巨大
- ✅ **明确clean场景**: 只有在以下情况才需要clean：
  - 修改了Cargo.toml或依赖配置文件
  - 出现链接错误或编译缓存损坏
  - 切换了不同的编译目标或特性
  - 明确需要完全重新构建
- ✅ **优先增量编译**: 使用`make build`而不是`make clean && make build`
- ✅ **配置优先**: 当测试失败时，优先检查路径、环境变量等配置问题，而不是立即clean重编译
- ❌ **习惯性clean**: 禁止习惯性地在每次编译前都执行clean操作
- ❌ **盲目重编译**: 禁止遇到问题就立即clean重编译，应先分析问题根因

### 20. 数据结构重复检查原则 🔍
**创建数据结构的时候，必须先检查系统中现在是否存在相同或是类似的数据结构。不应该随便创建新的数据结构**

**实施要求：**
- ✅ **创建前搜索**: 定义新数据结构前，必须先在整个代码库中搜索相似的现有结构
- ✅ **复用优先**: 优先使用、扩展现有数据结构，而不是创建新的
- ✅ **统一定义**: 所有数据结构必须在统一的位置定义（如types/data-structures.ts）
- ✅ **避免重复**: 发现重复定义时立即归并为单一定义
- ✅ **命名一致**: 相同功能的数据结构必须使用一致的命名规范
- ❌ **随意创建**: 禁止不检查现有结构就随意创建新的数据结构
- ❌ **多重定义**: 严禁同一数据结构在多个文件中重复定义
- ❌ **孤立定义**: 禁止在单个模块中定义通用数据结构

## 📋 规则检查清单

在开始编码前，请确认：

- [ ] 是否搜索了相似功能的现有实现？
- [ ] 是否确定了代码应该放置的正确模块？
- [ ] 是否对照了设计文档中的需求点？
- [ ] 是否会影响现有API接口？
- [ ] 是否需要创建新的store或hook？
- [ ] 是否通过统一的request模块调用API？
- [ ] 是否检查了重复代码？
- [ ] 是否需要修改数据库结构？
- [ ] 是否准备了相应的测试用例？
- [ ] 是否使用service-manager.sh管理服务启动？
- [ ] 是否检查了功能实现的唯一性？
- [ ] 启动服务前是否先停止进程并重新编译？
- [ ] 编译输出路径是否与启动脚本一致？
- [ ] 是否搜索了相似的数据结构避免重复定义？