from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.core.cache import cache
from django.db.models import Index, Q
import random
import json

# å¯¼å…¥èŠå¤©æ¨¡å‹ä»¥é¿å…å¾ªç¯å¯¼å…¥
from .chat_models import ChatRoom, ChatMessage


# ToolUsageLog å·²ç§»è‡³ base_models.pyï¼Œè¿™é‡Œä¸å†é‡å¤å®šä¹‰

class LifeDiaryEntry(models.Model):
    """ç”Ÿæ´»æ—¥è®°æ¡ç›®æ¨¡å‹"""
    MOOD_CHOICES = [
        ('happy', 'å¼€å¿ƒ'),
        ('calm', 'å¹³é™'),
        ('excited', 'å…´å¥‹'),
        ('sad', 'éš¾è¿‡'),
        ('angry', 'ç”Ÿæ°”'),
        ('neutral', 'ä¸€èˆ¬'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·', db_index=True)
    date = models.DateField(default=timezone.now, verbose_name='æ—¥æœŸ', db_index=True)
    title = models.CharField(max_length=200, verbose_name='æ ‡é¢˜')
    content = models.TextField(verbose_name='å†…å®¹')
    mood = models.CharField(max_length=20, choices=MOOD_CHOICES, verbose_name='å¿ƒæƒ…', db_index=True)
    mood_note = models.TextField(blank=True, null=True, verbose_name='å¿ƒæƒ…å¤‡æ³¨')
    tags = models.JSONField(default=list, verbose_name='æ ‡ç­¾')
    question_answers = models.JSONField(default=list, verbose_name='é—®é¢˜å›ç­”')
    music_recommendation = models.TextField(blank=True, null=True, verbose_name='éŸ³ä¹æ¨è')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´', db_index=True)
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-date', '-created_at']
        verbose_name = 'ç”Ÿæ´»æ—¥è®°'
        verbose_name_plural = 'ç”Ÿæ´»æ—¥è®°'
        indexes = [
            models.Index(fields=['user', 'date']),
            models.Index(fields=['user', 'mood']),
            models.Index(fields=['date', 'mood']),
            models.Index(fields=['user', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.date} - {self.title}"
    
    def get_mood_emoji(self):
        """è·å–å¿ƒæƒ…å¯¹åº”çš„è¡¨æƒ…ç¬¦å·"""
        mood_emojis = {
            'happy': 'ğŸ˜Š',
            'calm': 'ğŸ˜Œ',
            'excited': 'â­',
            'sad': 'ğŸ˜¢',
            'angry': 'ğŸ˜ ',
            'neutral': 'ğŸ˜'
        }
        return mood_emojis.get(self.mood, 'ğŸ˜')
    
    def get_word_count(self):
        """è·å–å†…å®¹å­—æ•°"""
        return len(self.content) if self.content else 0
    
    def get_tags_display(self):
        """è·å–æ ‡ç­¾æ˜¾ç¤ºæ–‡æœ¬"""
        return ', '.join(self.tags) if self.tags else 'æ— æ ‡ç­¾'

    @classmethod
    def get_user_diary_stats(cls, user, days=30):
        """è·å–ç”¨æˆ·æ—¥è®°ç»Ÿè®¡ï¼Œå¸¦ç¼“å­˜"""
        cache_key = f"diary_stats_{user.id}_{days}"
        stats = cache.get(cache_key)
        
        if stats is None:
            from datetime import timedelta
            start_date = timezone.now().date() - timedelta(days=days)
            
            queryset = cls.objects.filter(user=user, date__gte=start_date)
            
            stats = {
                'total_entries': queryset.count(),
                'mood_distribution': list(queryset.values('mood').annotate(count=models.Count('id'))),
                'total_words': sum(entry.get_word_count() for entry in queryset),
                'avg_words_per_entry': queryset.count() and sum(entry.get_word_count() for entry in queryset) / queryset.count() or 0,
                'most_common_mood': queryset.values('mood').annotate(count=models.Count('id')).order_by('-count').first()
            }
            cache.set(cache_key, stats, 300)  # ç¼“å­˜5åˆ†é’Ÿ
        
        return stats


class LifeGoal(models.Model):
    """ç”Ÿæ´»ç›®æ ‡æ¨¡å‹"""
    GOAL_STATUS_CHOICES = [
        ('active', 'è¿›è¡Œä¸­'),
        ('completed', 'å·²å®Œæˆ'),
        ('paused', 'æš‚åœ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    GOAL_CATEGORY_CHOICES = [
        ('health', 'å¥åº·'),
        ('career', 'äº‹ä¸š'),
        ('learning', 'å­¦ä¹ '),
        ('relationship', 'äººé™…å…³ç³»'),
        ('finance', 'è´¢åŠ¡'),
        ('hobby', 'å…´è¶£çˆ±å¥½'),
        ('spiritual', 'ç²¾ç¥æˆé•¿'),
        ('travel', 'æ—…è¡Œ'),
        ('other', 'å…¶ä»–'),
    ]
    
    GOAL_TYPE_CHOICES = [
        ('daily', 'æ¯æ—¥ç›®æ ‡'),
        ('weekly', 'æ¯å‘¨ç›®æ ‡'),
        ('monthly', 'æ¯æœˆç›®æ ‡'),
        ('quarterly', 'å­£åº¦ç›®æ ‡'),
        ('yearly', 'å¹´åº¦ç›®æ ‡'),
        ('lifetime', 'äººç”Ÿç›®æ ‡'),
    ]
    
    DIFFICULTY_CHOICES = [
        ('easy', 'ç®€å•'),
        ('medium', 'ä¸­ç­‰'),
        ('hard', 'å›°éš¾'),
        ('expert', 'ä¸“å®¶çº§'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·', db_index=True)
    title = models.CharField(max_length=200, verbose_name='ç›®æ ‡æ ‡é¢˜')
    description = models.TextField(blank=True, null=True, verbose_name='ç›®æ ‡æè¿°')
    category = models.CharField(max_length=20, choices=GOAL_CATEGORY_CHOICES, verbose_name='ç›®æ ‡ç±»åˆ«', db_index=True)
    goal_type = models.CharField(max_length=20, choices=GOAL_TYPE_CHOICES, default='daily', verbose_name='ç›®æ ‡ç±»å‹', db_index=True)
    status = models.CharField(max_length=20, choices=GOAL_STATUS_CHOICES, default='active', verbose_name='çŠ¶æ€', db_index=True)
    start_date = models.DateField(null=True, blank=True, verbose_name='å¼€å§‹æ—¥æœŸ')
    target_date = models.DateField(null=True, blank=True, verbose_name='ç›®æ ‡æ—¥æœŸ', db_index=True)
    progress = models.IntegerField(default=0, verbose_name='è¿›åº¦ç™¾åˆ†æ¯”')
    priority = models.IntegerField(default=5, verbose_name='ä¼˜å…ˆçº§(1-10)', db_index=True)
    difficulty = models.CharField(max_length=20, choices=DIFFICULTY_CHOICES, default='medium', verbose_name='éš¾åº¦ç­‰çº§')
    milestones = models.JSONField(default=list, verbose_name='é‡Œç¨‹ç¢‘')
    tags = models.JSONField(default=list, verbose_name='æ ‡ç­¾')
    reminder_enabled = models.BooleanField(default=True, verbose_name='å¯ç”¨æé†’')
    reminder_frequency = models.CharField(max_length=20, default='daily', verbose_name='æé†’é¢‘ç‡')
    reminder_time = models.TimeField(default='09:00', verbose_name='æé†’æ—¶é—´')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´', db_index=True)
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='å®Œæˆæ—¶é—´')
    
    class Meta:
        ordering = ['-priority', '-created_at']
        verbose_name = 'ç”Ÿæ´»ç›®æ ‡'
        verbose_name_plural = 'ç”Ÿæ´»ç›®æ ‡'
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['user', 'category']),
            models.Index(fields=['status', 'target_date']),
            models.Index(fields=['user', 'priority']),
            models.Index(fields=['user', 'goal_type']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.title}"
    
    def get_days_remaining(self):
        """è·å–å‰©ä½™å¤©æ•°"""
        if not self.target_date:
            return None
        from django.utils import timezone
        today = timezone.now().date()
        remaining = (self.target_date - today).days
        return max(0, remaining)
    
    def is_overdue(self):
        """æ£€æŸ¥æ˜¯å¦é€¾æœŸ"""
        if not self.target_date:
            return False
        from django.utils import timezone
        today = timezone.now().date()
        return self.target_date < today and self.status == 'active'
    
    def get_priority_color(self):
        """è·å–ä¼˜å…ˆçº§å¯¹åº”çš„é¢œè‰²"""
        if self.priority >= 8:
            return '#ff4444'  # çº¢è‰² - ç´§æ€¥
        elif self.priority >= 6:
            return '#ff8800'  # æ©™è‰² - é‡è¦
        else:
            return '#4CAF50'  # ç»¿è‰² - æ™®é€š
    
    def get_milestones_display(self):
        """è·å–é‡Œç¨‹ç¢‘æ˜¾ç¤ºæ–‡æœ¬"""
        if not self.milestones:
            return 'æ— é‡Œç¨‹ç¢‘'
        return f"{len(self.milestones)} ä¸ªé‡Œç¨‹ç¢‘"
    
    def get_tags_display(self):
        """è·å–æ ‡ç­¾æ˜¾ç¤ºæ–‡æœ¬"""
        return ', '.join(self.tags) if self.tags else 'æ— æ ‡ç­¾'

    @classmethod
    def get_user_goals_summary(cls, user):
        """è·å–ç”¨æˆ·ç›®æ ‡æ‘˜è¦ï¼Œå¸¦ç¼“å­˜"""
        cache_key = f"goals_summary_{user.id}"
        summary = cache.get(cache_key)
        
        if summary is None:
            goals = cls.objects.filter(user=user)
            
            summary = {
                'total_goals': goals.count(),
                'active_goals': goals.filter(status='active').count(),
                'completed_goals': goals.filter(status='completed').count(),
                'overdue_goals': goals.filter(status='active', target_date__lt=timezone.now().date()).count(),
                'category_breakdown': list(goals.values('category').annotate(count=models.Count('id'))),
                'priority_breakdown': list(goals.values('priority').annotate(count=models.Count('id'))),
            }
            cache.set(cache_key, summary, 300)  # ç¼“å­˜5åˆ†é’Ÿ
        
        return summary


class LifeGoalProgress(models.Model):
    """ç”Ÿæ´»ç›®æ ‡è¿›åº¦è®°å½•æ¨¡å‹"""
    goal = models.ForeignKey(LifeGoal, on_delete=models.CASCADE, verbose_name='ç›®æ ‡', db_index=True)
    date = models.DateField(auto_now_add=True, verbose_name='æ—¥æœŸ', db_index=True)
    progress_value = models.IntegerField(verbose_name='è¿›åº¦å€¼')
    notes = models.TextField(blank=True, null=True, verbose_name='è¿›åº¦å¤‡æ³¨')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´', db_index=True)
    
    class Meta:
        unique_together = ['goal', 'date']
        ordering = ['-date']
        verbose_name = 'ç›®æ ‡è¿›åº¦'
        verbose_name_plural = 'ç›®æ ‡è¿›åº¦'
        indexes = [
            models.Index(fields=['goal', 'date']),
            models.Index(fields=['date', 'progress_value']),
        ]
    
    def __str__(self):
        return f"{self.goal.title} - {self.date} - {self.progress_value}%"


class LifeStatistics(models.Model):
    """ç”Ÿæ´»ç»Ÿè®¡æ•°æ®æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·', db_index=True)
    date = models.DateField(auto_now_add=True, verbose_name='æ—¥æœŸ', db_index=True)
    total_diary_days = models.IntegerField(default=0, verbose_name='æ—¥è®°æ€»å¤©æ•°')
    total_diary_count = models.IntegerField(default=0, verbose_name='æ—¥è®°æ€»æ¬¡æ•°')
    happy_days = models.IntegerField(default=0, verbose_name='å¼€å¿ƒå¤©æ•°')
    total_goals = models.IntegerField(default=0, verbose_name='ç›®æ ‡æ€»æ•°')
    completed_goals = models.IntegerField(default=0, verbose_name='å·²å®Œæˆç›®æ ‡æ•°')
    mood_distribution = models.JSONField(default=dict, verbose_name='å¿ƒæƒ…åˆ†å¸ƒ')
    goal_completion_rate = models.FloatField(default=0.0, verbose_name='ç›®æ ‡å®Œæˆç‡')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        unique_together = ['user', 'date']
        ordering = ['-date']
        verbose_name = 'ç”Ÿæ´»ç»Ÿè®¡'
        verbose_name_plural = 'ç”Ÿæ´»ç»Ÿè®¡'
        indexes = [
            models.Index(fields=['user', 'date']),
            models.Index(fields=['date', 'goal_completion_rate']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.date} - ç»Ÿè®¡"


# ChatRoomæ¨¡å‹å·²ç§»åŠ¨åˆ°chat_models.py
# class ChatRoom(models.Model):
#     """èŠå¤©å®¤æ¨¡å‹"""
#     ROOM_STATUS_CHOICES = [
#         ('waiting', 'ç­‰å¾…åŒ¹é…'),
#         ('active', 'æ´»è·ƒ'),
#         ('ended', 'å·²ç»“æŸ'),
#     ]
#     
#     room_id = models.CharField(max_length=100, unique=True, db_index=True)  # æ·»åŠ ç´¢å¼•
#     user1 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='chat_rooms_1', db_index=True)
#     user2 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='chat_rooms_2', null=True, blank=True, db_index=True)
#     status = models.CharField(max_length=20, default='active', db_index=True)  # æ·»åŠ ç´¢å¼•
#     created_at = models.DateTimeField(auto_now_add=True, db_index=True)  # æ·»åŠ ç´¢å¼•
#     updated_at = models.DateTimeField(auto_now=True)
# 
#     class Meta:
#         indexes = [
#             models.Index(fields=['status', 'created_at']),
#             models.Index(fields=['user1', 'status']),
#             models.Index(fields=['user2', 'status']),
#             models.Index(fields=['user1', 'user2']),
#         ]
# 
#     def __str__(self):
#         return f"èŠå¤©å®¤ {self.room_id}"
#     
#     @property
#     def is_full(self):
#         return self.user2 is not None
#     
#     @property
#     def participants(self):
#         participants = [self.user1]
#         if self.user2:
#             participants.append(self.user2)
#         return participants
# 
#     @classmethod
#     def get_user_active_rooms(cls, user):
#         """è·å–ç”¨æˆ·æ´»è·ƒèŠå¤©å®¤ï¼Œå¸¦ç¼“å­˜"""
#         cache_key = f"active_rooms_{user.id}"
#         rooms = cache.get(cache_key)
#         
#         if rooms is None:
#             rooms = list(cls.objects.filter(
#                 Q(user1=user) | Q(user2=user),
#                 status='active'
#             ).select_related('user1', 'user2'))
#             cache.set(cache_key, rooms, 60)  # ç¼“å­˜1åˆ†é’Ÿ
#         
#         return rooms


# ChatMessageæ¨¡å‹å·²ç§»åŠ¨åˆ°chat_models.py
# class ChatMessage(models.Model):
#     """èŠå¤©æ¶ˆæ¯æ¨¡å‹"""
#     MESSAGE_TYPES = [
#         ('text', 'æ–‡æœ¬'),
#         ('image', 'å›¾ç‰‡'),
#         ('file', 'æ–‡ä»¶'),
#         ('emoji', 'è¡¨æƒ…'),
#         ('video', 'è§†é¢‘'),
#         ('audio', 'è¯­éŸ³'),
#     ]
#     
#     room = models.ForeignKey(ChatRoom, on_delete=models.CASCADE, related_name='chat_messages', db_index=True)
#     sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sent_messages', db_index=True)
#     message_type = models.CharField(max_length=20, default='text', db_index=True)  # æ·»åŠ ç´¢å¼•
#     content = models.TextField()
#     file_url = models.URLField(blank=True, null=True, verbose_name='æ–‡ä»¶URL')
#     is_read = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²è¯»', db_index=True)
#     created_at = models.DateTimeField(auto_now_add=True, db_index=True)  # æ·»åŠ ç´¢å¼•
#     
#     class Meta:
#         indexes = [
#             models.Index(fields=['room', 'created_at']),
#             models.Index(fields=['sender', 'created_at']),
#             models.Index(fields=['message_type', 'created_at']),
#             models.Index(fields=['room', 'is_read']),
#         ]
#         verbose_name = 'èŠå¤©æ¶ˆæ¯'
#         verbose_name_plural = 'èŠå¤©æ¶ˆæ¯'
#         ordering = ['created_at']
#     
#     def __str__(self):
#         return f"{self.sender.username}: {self.content[:50]}"
# 
#     @classmethod
#     def get_room_messages(cls, room, limit=50, offset=0):
#         """è·å–èŠå¤©å®¤æ¶ˆæ¯ï¼Œå¸¦åˆ†é¡µå’Œç¼“å­˜"""
#         cache_key = f"room_messages_{room.id}_{limit}_{offset}"
#         messages = cache.get(cache_key)
#         
#         if messages is None:
#             messages = list(cls.objects.filter(room=room).select_related('sender').order_by('-created_at')[offset:offset+limit])
#             cache.set(cache_key, messages, 30)  # ç¼“å­˜30ç§’
#         
#         return messages

    @classmethod
    def get_unread_count(cls, user, room):
        """è·å–ç”¨æˆ·åœ¨æŒ‡å®šæˆ¿é—´çš„æœªè¯»æ¶ˆæ¯æ•°"""
        return cls.objects.filter(
            room=room,
            sender__in=room.participants,
            is_read=False
        ).exclude(sender=user).count()


# UserOnlineStatusæ¨¡å‹å·²ç§»åŠ¨åˆ°chat_models.py
# class UserOnlineStatus(models.Model):
#     """ç”¨æˆ·åœ¨çº¿çŠ¶æ€æ¨¡å‹"""
#     STATUS_CHOICES = [
#         ('online', 'åœ¨çº¿'),
#         ('busy', 'å¿™ç¢Œ'),
#         ('away', 'ç¦»å¼€'),
#         ('offline', 'ç¦»çº¿'),
#     ]
#     
#     user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='online_status', verbose_name='ç”¨æˆ·')
#     status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='offline', verbose_name='åœ¨çº¿çŠ¶æ€', db_index=True)
#     last_seen = models.DateTimeField(auto_now=True, verbose_name='æœ€ååœ¨çº¿æ—¶é—´', db_index=True)
#     is_typing = models.BooleanField(default=False, verbose_name='æ˜¯å¦æ­£åœ¨è¾“å…¥')
#     current_room = models.ForeignKey(ChatRoom, on_delete=models.SET_NULL, null=True, blank=True, related_name='online_users', verbose_name='å½“å‰æˆ¿é—´')
#     is_online = models.BooleanField(default=False, verbose_name='æ˜¯å¦åœ¨çº¿', db_index=True)
#     match_number = models.CharField(max_length=4, null=True, blank=True, verbose_name='åŒ¹é…æ•°å­—')
#     
#     class Meta:
#         verbose_name = 'ç”¨æˆ·åœ¨çº¿çŠ¶æ€'
#         verbose_name_plural = 'ç”¨æˆ·åœ¨çº¿çŠ¶æ€'
#         indexes = [
#             models.Index(fields=['status', 'last_seen']),
#             models.Index(fields=['is_online', 'last_seen']),
#         ]
#     
#     def __str__(self):
#         return f"{self.user.username} - {self.get_status_display()}"
# 
#     @classmethod
#     def get_online_users(cls):
#         """è·å–åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼Œå¸¦ç¼“å­˜"""
#         cache_key = "online_users"
#         users = cache.get(cache_key)
#         
#         if users is None:
#             users = list(cls.objects.filter(is_online=True).select_related('user'))
#             cache.set(cache_key, users, 30)  # ç¼“å­˜30ç§’
#         
#         return users


# HeartLinkRequestæ¨¡å‹å·²ç§»åŠ¨åˆ°chat_models.py
# class HeartLinkRequest(models.Model):
#     """å¿ƒåŠ¨é“¾æ¥è¯·æ±‚æ¨¡å‹"""
#     STATUS_CHOICES = [
#         ('pending', 'ç­‰å¾…ä¸­'),
#         ('matching', 'åŒ¹é…ä¸­'),
#         ('matched', 'å·²åŒ¹é…'),
#         ('expired', 'å·²è¿‡æœŸ'),
#         ('cancelled', 'å·²å–æ¶ˆ'),
#     ]
#     
#     requester = models.ForeignKey(User, on_delete=models.CASCADE, related_name='heart_link_requests', db_index=True)
#     status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', db_index=True)  # æ·»åŠ ç´¢å¼•
#     created_at = models.DateTimeField(auto_now_add=True, db_index=True)  # æ·»åŠ ç´¢å¼•
#     matched_at = models.DateTimeField(null=True, blank=True, verbose_name='åŒ¹é…æ—¶é—´')
#     matched_with = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='matched_heart_links', verbose_name='åŒ¹é…ç”¨æˆ·')
#     chat_room = models.ForeignKey(ChatRoom, on_delete=models.CASCADE, related_name='heart_link_requests', db_index=True)
#     
#     class Meta:
#         indexes = [
#             models.Index(fields=['requester', 'status']),
#             models.Index(fields=['chat_room', 'status']),
#             models.Index(fields=['status', 'created_at']),
#             models.Index(fields=['matched_with', 'status']),
#         ]
#         verbose_name = 'å¿ƒåŠ¨é“¾æ¥è¯·æ±‚'
#         verbose_name_plural = 'å¿ƒåŠ¨é“¾æ¥è¯·æ±‚'
#         ordering = ['-created_at']
#         unique_together = ['requester', 'chat_room']
#     
#     def __str__(self):
#         return f"{self.requester.username} çš„å¿ƒåŠ¨é“¾æ¥è¯·æ±‚"
#     
#     @property
#     def is_expired(self):
#         """æ£€æŸ¥è¯·æ±‚æ˜¯å¦è¿‡æœŸï¼ˆ10åˆ†é’Ÿï¼‰"""
#         from django.utils import timezone
#         from datetime import timedelta
#         return timezone.now() > self.created_at + timedelta(minutes=10)
# 
#     @classmethod
#     def get_pending_requests(cls):
#         """è·å–å¾…å¤„ç†çš„è¯·æ±‚ï¼Œå¸¦ç¼“å­˜"""
#         cache_key = "pending_heart_requests"
#         requests = cache.get(cache_key)
#         
#         if requests is None:
#             requests = list(cls.objects.filter(status='pending').select_related('requester'))
#             cache.set(cache_key, requests, 30)  # ç¼“å­˜30ç§’
#         
#         return requests


class UserAchievement(models.Model):
    """ç”¨æˆ·æˆå°±æ¨¡å‹"""
    ACHIEVEMENT_TYPE_CHOICES = [
        ('diary', 'æ—¥è®°æˆå°±'),
        ('goal', 'ç›®æ ‡æˆå°±'),
        ('streak', 'è¿ç»­æˆå°±'),
        ('milestone', 'é‡Œç¨‹ç¢‘æˆå°±'),
        ('custom', 'è‡ªå®šä¹‰æˆå°±'),
    ]
    
    ACHIEVEMENT_LEVEL_CHOICES = [
        ('bronze', 'é“œç‰Œ'),
        ('silver', 'é“¶ç‰Œ'),
        ('gold', 'é‡‘ç‰Œ'),
        ('platinum', 'ç™½é‡‘'),
        ('diamond', 'é’»çŸ³'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·', db_index=True)
    title = models.CharField(max_length=200, verbose_name='æˆå°±æ ‡é¢˜')
    description = models.TextField(blank=True, null=True, verbose_name='æˆå°±æè¿°')
    achievement_type = models.CharField(max_length=20, choices=ACHIEVEMENT_TYPE_CHOICES, verbose_name='æˆå°±ç±»å‹', db_index=True)
    level = models.CharField(max_length=20, choices=ACHIEVEMENT_LEVEL_CHOICES, default='bronze', verbose_name='æˆå°±ç­‰çº§')
    icon = models.CharField(max_length=50, default='fas fa-trophy', verbose_name='æˆå°±å›¾æ ‡')
    is_custom = models.BooleanField(default=False, verbose_name='æ˜¯å¦è‡ªå®šä¹‰')
    is_public = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¬å¼€')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è·å¾—æ—¶é—´', db_index=True)
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'ç”¨æˆ·æˆå°±'
        verbose_name_plural = 'ç”¨æˆ·æˆå°±'
        indexes = [
            models.Index(fields=['user', 'achievement_type']),
            models.Index(fields=['user', 'level']),
            models.Index(fields=['achievement_type', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.title}"
    
    def get_level_color(self):
        """è·å–æˆå°±ç­‰çº§å¯¹åº”çš„é¢œè‰²"""
        colors = {
            'bronze': '#cd7f32',
            'silver': '#c0c0c0',
            'gold': '#ffd700',
            'platinum': '#e5e4e2',
            'diamond': '#b9f2ff',
        }
        return colors.get(self.level, '#cd7f32')
    
    def get_icon_class(self):
        """è·å–æˆå°±å›¾æ ‡ç±»å"""
        return self.icon if self.icon else 'fas fa-trophy'

    @classmethod
    def get_user_achievements_summary(cls, user):
        """è·å–ç”¨æˆ·æˆå°±æ‘˜è¦ï¼Œå¸¦ç¼“å­˜"""
        cache_key = f"achievements_summary_{user.id}"
        summary = cache.get(cache_key)
        
        if summary is None:
            achievements = cls.objects.filter(user=user)
            
            summary = {
                'total_achievements': achievements.count(),
                'level_breakdown': list(achievements.values('level').annotate(count=models.Count('id'))),
                'type_breakdown': list(achievements.values('achievement_type').annotate(count=models.Count('id'))),
                'recent_achievements': list(achievements.order_by('-created_at')[:5].values('title', 'level', 'created_at')),
            }
            cache.set(cache_key, summary, 300)  # ç¼“å­˜5åˆ†é’Ÿ
        
        return summary


class FitnessWorkoutSession(models.Model):
    """å¥èº«è®­ç»ƒä¼šè¯æ¨¡å‹"""
    WORKOUT_TYPE_CHOICES = [
        ('strength', 'åŠ›é‡è®­ç»ƒ'),
        ('cardio', 'æœ‰æ°§è¿åŠ¨'),
        ('flexibility', 'æŸ”éŸ§æ€§è®­ç»ƒ'),
        ('balance', 'å¹³è¡¡è®­ç»ƒ'),
        ('mixed', 'æ··åˆè®­ç»ƒ'),
    ]
    
    INTENSITY_CHOICES = [
        ('light', 'è½»åº¦'),
        ('moderate', 'ä¸­åº¦'),
        ('intense', 'é«˜å¼ºåº¦'),
        ('extreme', 'æé™'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    workout_type = models.CharField(max_length=20, choices=WORKOUT_TYPE_CHOICES, verbose_name='è®­ç»ƒç±»å‹')
    intensity = models.CharField(max_length=20, choices=INTENSITY_CHOICES, verbose_name='å¼ºåº¦ç­‰çº§')
    duration_minutes = models.IntegerField(verbose_name='è®­ç»ƒæ—¶é•¿(åˆ†é’Ÿ)')
    calories_burned = models.IntegerField(default=0, verbose_name='æ¶ˆè€—å¡è·¯é‡Œ')
    heart_rate_avg = models.IntegerField(default=0, verbose_name='å¹³å‡å¿ƒç‡')
    heart_rate_max = models.IntegerField(default=0, verbose_name='æœ€å¤§å¿ƒç‡')
    exercises = models.JSONField(default=list, verbose_name='è®­ç»ƒåŠ¨ä½œ')
    notes = models.TextField(blank=True, null=True, verbose_name='è®­ç»ƒç¬”è®°')
    audio_recording_url = models.URLField(blank=True, null=True, verbose_name='å–˜æ¯å½•éŸ³')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è®­ç»ƒæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'å¥èº«è®­ç»ƒ'
        verbose_name_plural = 'å¥èº«è®­ç»ƒ'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_workout_type_display()} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"


class CodeWorkoutSession(models.Model):
    """ä»£ç è®­ç»ƒä¼šè¯æ¨¡å‹"""
    WORKOUT_TYPE_CHOICES = [
        ('pull_up', 'å¼•ä½“å‘ä¸Š(åŸç”ŸJS)'),
        ('plank', 'å¹³æ¿æ”¯æ’‘(æ‹’ç»AI)'),
        ('squat', 'æ·±è¹²(é‡æ„å‡½æ•°)'),
        ('push_up', 'ä¿¯å§æ’‘(æ‰‹å†™ç®—æ³•)'),
        ('burpee', 'æ³¢æ¯”è·³(è°ƒè¯•ä»£ç )'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    workout_type = models.CharField(max_length=20, choices=WORKOUT_TYPE_CHOICES, verbose_name='è®­ç»ƒç±»å‹')
    duration_seconds = models.IntegerField(verbose_name='è®­ç»ƒæ—¶é•¿(ç§’)')
    difficulty_level = models.IntegerField(default=1, verbose_name='éš¾åº¦ç­‰çº§')
    code_snippet = models.TextField(blank=True, null=True, verbose_name='ä»£ç ç‰‡æ®µ')
    ai_rejection_count = models.IntegerField(default=0, verbose_name='æ‹’ç»AIæ¬¡æ•°')
    manual_code_lines = models.IntegerField(default=0, verbose_name='æ‰‹å†™ä»£ç è¡Œæ•°')
    refactored_functions = models.IntegerField(default=0, verbose_name='é‡æ„å‡½æ•°æ•°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è®­ç»ƒæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'ä»£ç è®­ç»ƒ'
        verbose_name_plural = 'ä»£ç è®­ç»ƒ'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_workout_type_display()} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"


class ExhaustionProof(models.Model):
    """åŠ›ç«­è¯æ˜NFTæ¨¡å‹"""
    PROOF_TYPE_CHOICES = [
        ('fitness', 'å¥èº«åŠ›ç«­'),
        ('coding', 'ç¼–ç¨‹åŠ›ç«­'),
        ('mental', 'ç²¾ç¥åŠ›ç«­'),
        ('mixed', 'æ··åˆåŠ›ç«­'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    proof_type = models.CharField(max_length=20, choices=PROOF_TYPE_CHOICES, verbose_name='è¯æ˜ç±»å‹')
    title = models.CharField(max_length=200, verbose_name='è¯æ˜æ ‡é¢˜')
    description = models.TextField(verbose_name='è¯æ˜æè¿°')
    heart_rate_data = models.JSONField(default=dict, verbose_name='å¿ƒç‡æ•°æ®')
    audio_recording_url = models.URLField(blank=True, null=True, verbose_name='å½•éŸ³æ–‡ä»¶')
    nft_metadata = models.JSONField(default=dict, verbose_name='NFTå…ƒæ•°æ®')
    nft_token_id = models.CharField(max_length=100, blank=True, null=True, verbose_name='NFTä»£å¸ID')
    blockchain_tx_hash = models.CharField(max_length=200, blank=True, null=True, verbose_name='åŒºå—é“¾äº¤æ˜“å“ˆå¸Œ')
    is_minted = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²é“¸é€ ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'åŠ›ç«­è¯æ˜'
        verbose_name_plural = 'åŠ›ç«­è¯æ˜'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_proof_type_display()} - {self.title}"


class AIDependencyMeter(models.Model):
    """AIä¾èµ–åº¦ä»ªè¡¨æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    total_code_lines = models.IntegerField(default=0, verbose_name='æ€»ä»£ç è¡Œæ•°')
    ai_generated_lines = models.IntegerField(default=0, verbose_name='AIç”Ÿæˆä»£ç è¡Œæ•°')
    manual_code_lines = models.IntegerField(default=0, verbose_name='æ‰‹å†™ä»£ç è¡Œæ•°')
    ai_rejection_count = models.IntegerField(default=0, verbose_name='æ‹’ç»AIæ¬¡æ•°')
    dependency_score = models.FloatField(default=0.0, verbose_name='ä¾èµ–åº¦è¯„åˆ†')
    last_updated = models.DateTimeField(auto_now=True, verbose_name='æœ€åæ›´æ–°')
    
    class Meta:
        verbose_name = 'AIä¾èµ–åº¦ä»ªè¡¨'
        verbose_name_plural = 'AIä¾èµ–åº¦ä»ªè¡¨'
    
    def __str__(self):
        return f"{self.user.username} - ä¾èµ–åº¦: {self.dependency_score:.2f}%"
    
    def calculate_dependency_score(self):
        """è®¡ç®—AIä¾èµ–åº¦è¯„åˆ†"""
        if self.total_code_lines == 0:
            return 0.0
        return (self.ai_generated_lines / self.total_code_lines) * 100


class CoPilotCollaboration(models.Model):
    """AIåä½œå£°æ˜æ¨¡å‹"""
    COLLABORATION_TYPE_CHOICES = [
        ('skeleton', 'éª¨æ¶ä»£ç '),
        ('muscle', 'è‚Œè‚‰ä»£ç '),
        ('nervous', 'ç¥ç»ç³»ç»Ÿ'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    collaboration_type = models.CharField(max_length=20, choices=COLLABORATION_TYPE_CHOICES, verbose_name='åä½œç±»å‹')
    original_code = models.TextField(verbose_name='åŸå§‹ä»£ç ')
    ai_generated_code = models.TextField(verbose_name='AIç”Ÿæˆä»£ç ')
    final_code = models.TextField(verbose_name='æœ€ç»ˆä»£ç ')
    project_name = models.CharField(max_length=200, verbose_name='é¡¹ç›®åç§°')
    description = models.TextField(blank=True, null=True, verbose_name='åä½œæè¿°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'AIåä½œå£°æ˜'
        verbose_name_plural = 'AIåä½œå£°æ˜'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_collaboration_type_display()} - {self.project_name}"


class DailyWorkoutChallenge(models.Model):
    """æ¯æ—¥è®­ç»ƒæŒ‘æˆ˜æ¨¡å‹"""
    CHALLENGE_TYPE_CHOICES = [
        ('fitness', 'å¥èº«æŒ‘æˆ˜'),
        ('coding', 'ç¼–ç¨‹æŒ‘æˆ˜'),
        ('mixed', 'æ··åˆæŒ‘æˆ˜'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    challenge_type = models.CharField(max_length=20, choices=CHALLENGE_TYPE_CHOICES, verbose_name='æŒ‘æˆ˜ç±»å‹')
    date = models.DateField(auto_now_add=True, verbose_name='æŒ‘æˆ˜æ—¥æœŸ')
    tasks = models.JSONField(default=list, verbose_name='æŒ‘æˆ˜ä»»åŠ¡')
    completed_tasks = models.JSONField(default=list, verbose_name='å®Œæˆä»»åŠ¡')
    total_score = models.IntegerField(default=0, verbose_name='æ€»å¾—åˆ†')
    is_completed = models.BooleanField(default=False, verbose_name='æ˜¯å¦å®Œæˆ')
    reward_unlocked = models.BooleanField(default=False, verbose_name='æ˜¯å¦è§£é”å¥–åŠ±')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='å®Œæˆæ—¶é—´')
    
    class Meta:
        unique_together = ['user', 'date']
        ordering = ['-date']
        verbose_name = 'æ¯æ—¥è®­ç»ƒæŒ‘æˆ˜'
        verbose_name_plural = 'æ¯æ—¥è®­ç»ƒæŒ‘æˆ˜'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_challenge_type_display()} - {self.date}"


class PainCurrency(models.Model):
    """ç—›è‹¦è´§å¸æ¨¡å‹"""
    CURRENCY_TYPE_CHOICES = [
        ('exhaustion', 'åŠ›ç«­å¸'),
        ('rejection', 'æ‹’ç»å¸'),
        ('manual', 'æ‰‹å†™å¸'),
        ('breakthrough', 'çªç ´å¸'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    currency_type = models.CharField(max_length=20, choices=CURRENCY_TYPE_CHOICES, verbose_name='è´§å¸ç±»å‹')
    amount = models.IntegerField(default=0, verbose_name='æ•°é‡')
    total_earned = models.IntegerField(default=0, verbose_name='æ€»è·å¾—')
    total_spent = models.IntegerField(default=0, verbose_name='æ€»æ¶ˆè´¹')
    last_earned = models.DateTimeField(auto_now=True, verbose_name='æœ€åè·å¾—æ—¶é—´')
    
    class Meta:
        unique_together = ['user', 'currency_type']
        verbose_name = 'ç—›è‹¦è´§å¸'
        verbose_name_plural = 'ç—›è‹¦è´§å¸'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_currency_type_display()}: {self.amount}"


class WorkoutDashboard(models.Model):
    """è®­ç»ƒä»ªè¡¨ç›˜æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    total_workouts = models.IntegerField(default=0, verbose_name='æ€»è®­ç»ƒæ¬¡æ•°')
    total_duration = models.IntegerField(default=0, verbose_name='æ€»è®­ç»ƒæ—¶é•¿(åˆ†é’Ÿ)')
    total_calories = models.IntegerField(default=0, verbose_name='æ€»æ¶ˆè€—å¡è·¯é‡Œ')
    current_streak = models.IntegerField(default=0, verbose_name='å½“å‰è¿ç»­å¤©æ•°')
    longest_streak = models.IntegerField(default=0, verbose_name='æœ€é•¿è¿ç»­å¤©æ•°')
    favorite_workout = models.CharField(max_length=50, blank=True, null=True, verbose_name='æœ€çˆ±è®­ç»ƒ')
    weekly_stats = models.JSONField(default=dict, verbose_name='å‘¨ç»Ÿè®¡')
    monthly_stats = models.JSONField(default=dict, verbose_name='æœˆç»Ÿè®¡')
    last_updated = models.DateTimeField(auto_now=True, verbose_name='æœ€åæ›´æ–°')
    
    class Meta:
        verbose_name = 'è®­ç»ƒä»ªè¡¨ç›˜'
        verbose_name_plural = 'è®­ç»ƒä»ªè¡¨ç›˜'
    
    def __str__(self):
        return f"{self.user.username} - è®­ç»ƒä»ªè¡¨ç›˜"


class DesireDashboard(models.Model):
    """æ¬²æœ›ä»ªè¡¨ç›˜æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    current_desire_level = models.IntegerField(default=50, verbose_name='å½“å‰æ¬²æœ›æµ“åº¦')
    total_desires = models.IntegerField(default=0, verbose_name='æ€»æ¬²æœ›æ•°')
    fulfilled_desires = models.IntegerField(default=0, verbose_name='å·²æ»¡è¶³æ¬²æœ›æ•°')
    last_updated = models.DateTimeField(auto_now=True, verbose_name='æœ€åæ›´æ–°')
    
    class Meta:
        verbose_name = 'æ¬²æœ›ä»ªè¡¨ç›˜'
        verbose_name_plural = 'æ¬²æœ›ä»ªè¡¨ç›˜'
    
    def __str__(self):
        return f"{self.user.username} - æ¬²æœ›æµ“åº¦: {self.current_desire_level}%"


class DesireItem(models.Model):
    """æ¬²æœ›é¡¹ç›®æ¨¡å‹"""
    DESIRE_TYPE_CHOICES = [
        ('material', 'ç‰©è´¨æ¬²æœ›'),
        ('social', 'ç¤¾äº¤æ¬²æœ›'),
        ('escape', 'é€ƒé¿æ¬²æœ›'),
        ('achievement', 'æˆå°±æ¬²æœ›'),
        ('recognition', 'è®¤å¯æ¬²æœ›'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    desire_type = models.CharField(max_length=20, choices=DESIRE_TYPE_CHOICES, verbose_name='æ¬²æœ›ç±»å‹')
    title = models.CharField(max_length=200, verbose_name='æ¬²æœ›æ ‡é¢˜')
    description = models.TextField(blank=True, null=True, verbose_name='æ¬²æœ›æè¿°')
    intensity = models.IntegerField(default=3, verbose_name='æ¬²æœ›å¼ºåº¦(1-5)')
    is_fulfilled = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²æ»¡è¶³')
    fulfillment_condition = models.TextField(blank=True, null=True, verbose_name='æ»¡è¶³æ¡ä»¶')
    fulfillment_image_url = models.URLField(blank=True, null=True, verbose_name='å…‘ç°å›¾ç‰‡URL')
    ai_generated_image = models.TextField(blank=True, null=True, verbose_name='AIç”Ÿæˆå›¾ç‰‡æè¿°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    fulfilled_at = models.DateTimeField(null=True, blank=True, verbose_name='æ»¡è¶³æ—¶é—´')
    
    class Meta:
        ordering = ['-intensity', '-created_at']
        verbose_name = 'æ¬²æœ›é¡¹ç›®'
        verbose_name_plural = 'æ¬²æœ›é¡¹ç›®'
    
    def __str__(self):
        return f"{self.user.username} - {self.title} ({self.get_intensity_stars()})"
    
    def get_intensity_stars(self):
        """è·å–å¼ºåº¦æ˜Ÿçº§æ˜¾ç¤º"""
        return 'â˜…' * self.intensity + 'â˜†' * (5 - self.intensity)


class DesireFulfillment(models.Model):
    """æ¬²æœ›å…‘ç°è®°å½•æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    desire = models.ForeignKey(DesireItem, on_delete=models.CASCADE, verbose_name='æ¬²æœ›é¡¹ç›®')
    task_completed = models.CharField(max_length=200, verbose_name='å®Œæˆä»»åŠ¡')
    task_details = models.TextField(blank=True, null=True, verbose_name='ä»»åŠ¡è¯¦æƒ…')
    fulfillment_image_url = models.URLField(blank=True, null=True, verbose_name='å…‘ç°å›¾ç‰‡URL')
    ai_prompt = models.TextField(verbose_name='AIç”Ÿæˆæç¤ºè¯')
    ai_generated_image = models.TextField(blank=True, null=True, verbose_name='AIç”Ÿæˆå›¾ç‰‡')
    satisfaction_level = models.IntegerField(default=5, verbose_name='æ»¡è¶³åº¦(1-10)')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å…‘ç°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ¬²æœ›å…‘ç°è®°å½•'
        verbose_name_plural = 'æ¬²æœ›å…‘ç°è®°å½•'
    
    def __str__(self):
        return f"{self.user.username} - {self.desire.title} å…‘ç°è®°å½•"


# VanityOS æ¬²æœ›é©±åŠ¨çš„å¼€å‘è€…æ¿€åŠ±ç³»ç»Ÿæ¨¡å‹

class VanityWealth(models.Model):
    """è™šæ‹Ÿè´¢å¯Œæ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    virtual_wealth = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name='è™šæ‹Ÿè´¢å¯Œ')
    code_lines = models.IntegerField(default=0, verbose_name='ä»£ç è¡Œæ•°')
    page_views = models.IntegerField(default=0, verbose_name='ç½‘ç«™è®¿é—®é‡')
    donations = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name='èµåŠ©é‡‘é¢')
    last_updated = models.DateTimeField(auto_now=True, verbose_name='æœ€åæ›´æ–°')
    
    class Meta:
        verbose_name = 'è™šæ‹Ÿè´¢å¯Œ'
        verbose_name_plural = 'è™šæ‹Ÿè´¢å¯Œ'
    
    def __str__(self):
        return f"{self.user.username} - è™šæ‹Ÿè´¢å¯Œ: {self.virtual_wealth}"
    
    def calculate_wealth(self):
        """è®¡ç®—è™šæ‹Ÿè´¢å¯Œ"""
        from decimal import Decimal
        code_wealth = Decimal(str(self.code_lines * 0.01))
        page_wealth = Decimal(str(self.page_views * 0.001))
        donation_wealth = Decimal(str(self.donations))
        self.virtual_wealth = code_wealth + page_wealth + donation_wealth
        return self.virtual_wealth


class SinPoints(models.Model):
    """ç½ªæ¶ç§¯åˆ†æ¨¡å‹"""
    ACTION_CHOICES = [
        ('code_line', 'æäº¤ä»£ç è¡Œ'),
        ('reject_ai', 'æ‹’ç»AIè¡¥å…¨'),
        ('deep_work', 'æ·±åº¦å·¥ä½œ'),
        ('donation', 'æ”¶åˆ°èµåŠ©'),
        ('manual_code', 'æ‰‹å†™ä»£ç '),
        ('refactor', 'é‡æ„ä»£ç '),
        ('debug', 'è°ƒè¯•ä»£ç '),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    action_type = models.CharField(max_length=20, choices=ACTION_CHOICES, verbose_name='è¡Œä¸ºç±»å‹')
    points_earned = models.IntegerField(verbose_name='è·å¾—ç§¯åˆ†')
    metadata = models.JSONField(default=dict, verbose_name='å…ƒæ•°æ®')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è·å¾—æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'ç½ªæ¶ç§¯åˆ†'
        verbose_name_plural = 'ç½ªæ¶ç§¯åˆ†'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_action_type_display()} - {self.points_earned}ç§¯åˆ†"


class Sponsor(models.Model):
    """èµåŠ©è€…æ¨¡å‹"""
    EFFECT_CHOICES = [
        ('golden-bling', 'é‡‘è‰²é—ªè€€'),
        ('diamond-sparkle', 'é’»çŸ³é—ªçƒ'),
        ('platinum-glow', 'ç™½é‡‘å…‰èŠ’'),
        ('silver-shine', 'é“¶è‰²å…‰è¾‰'),
    ]
    
    name = models.CharField(max_length=200, verbose_name='èµåŠ©è€…å§“å')
    amount = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='èµåŠ©é‡‘é¢')
    message = models.TextField(blank=True, null=True, verbose_name='èµåŠ©ç•™è¨€')
    effect = models.CharField(max_length=20, choices=EFFECT_CHOICES, default='golden-bling', verbose_name='ç‰¹æ•ˆç±»å‹')
    is_anonymous = models.BooleanField(default=False, verbose_name='æ˜¯å¦åŒ¿å')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='èµåŠ©æ—¶é—´')
    
    class Meta:
        ordering = ['-amount', '-created_at']
        verbose_name = 'èµåŠ©è€…'
        verbose_name_plural = 'èµåŠ©è€…'
    
    def __str__(self):
        display_name = "åŒ¿ååœŸè±ª" if self.is_anonymous else self.name
        return f"{display_name} - {self.amount}å…ƒ"


class VanityTask(models.Model):
    """æ¬²æœ›é©±åŠ¨å¾…åŠä»»åŠ¡æ¨¡å‹"""
    TASK_TYPE_CHOICES = [
        ('code_refactor', 'ä»£ç é‡æ„'),
        ('bug_fix', 'ä¿®å¤Bug'),
        ('feature_dev', 'åŠŸèƒ½å¼€å‘'),
        ('blog_write', 'å†™æŠ€æœ¯åšå®¢'),
        ('code_review', 'ä»£ç å®¡æŸ¥'),
        ('testing', 'æµ‹è¯•ç¼–å†™'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    title = models.CharField(max_length=200, verbose_name='ä»»åŠ¡æ ‡é¢˜')
    description = models.TextField(blank=True, null=True, verbose_name='ä»»åŠ¡æè¿°')
    task_type = models.CharField(max_length=20, choices=TASK_TYPE_CHOICES, verbose_name='ä»»åŠ¡ç±»å‹')
    difficulty = models.IntegerField(default=1, verbose_name='éš¾åº¦ç­‰çº§(1-10)')
    reward_value = models.IntegerField(default=0, verbose_name='å¥–åŠ±ä»·å€¼')
    reward_description = models.CharField(max_length=200, verbose_name='å¥–åŠ±æè¿°')
    is_completed = models.BooleanField(default=False, verbose_name='æ˜¯å¦å®Œæˆ')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='å®Œæˆæ—¶é—´')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ¬²æœ›ä»»åŠ¡'
        verbose_name_plural = 'æ¬²æœ›ä»»åŠ¡'
    
    def __str__(self):
        return f"{self.user.username} - {self.title}"
    
    def calculate_reward(self):
        """æ ¹æ®éš¾åº¦è®¡ç®—å¥–åŠ±"""
        self.reward_value = self.difficulty * 10
        return self.reward_value


class BasedDevAvatar(models.Model):
    """åç¨‹åºå‘˜å½¢è±¡æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    avatar_image = models.ImageField(upload_to='vanity_avatars/', verbose_name='å¤´åƒå›¾ç‰‡')
    code_snippet = models.TextField(verbose_name='ä»£ç ç‰‡æ®µ')
    caption = models.CharField(max_length=500, verbose_name='é…æ–‡')
    is_public = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¬å¼€')
    likes_count = models.IntegerField(default=0, verbose_name='ç‚¹èµæ•°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'åç¨‹åºå‘˜å½¢è±¡'
        verbose_name_plural = 'åç¨‹åºå‘˜å½¢è±¡'
    
    def __str__(self):
        return f"{self.user.username} - {self.caption[:50]}"


class TravelGuide(models.Model):
    """æ—…æ¸¸æ”»ç•¥æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    destination = models.CharField(max_length=200, verbose_name='ç›®çš„åœ°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    # æ”»ç•¥å†…å®¹
    must_visit_attractions = models.JSONField(default=list, verbose_name='å¿…å»æ™¯ç‚¹')
    food_recommendations = models.JSONField(default=list, verbose_name='ç¾é£Ÿæ¨è')
    transportation_guide = models.JSONField(default=dict, verbose_name='äº¤é€šæŒ‡å—')
    hidden_gems = models.JSONField(default=list, verbose_name='éšè—ç©æ³•')
    weather_info = models.JSONField(default=dict, verbose_name='å¤©æ°”ä¿¡æ¯')
    
    # Overviewä¿¡æ¯å­—æ®µ
    destination_info = models.JSONField(default=dict, verbose_name='ç›®çš„åœ°åŸºæœ¬ä¿¡æ¯')
    currency_info = models.JSONField(default=dict, verbose_name='æ±‡ç‡ä¿¡æ¯') 
    timezone_info = models.JSONField(default=dict, verbose_name='æ—¶åŒºä¿¡æ¯')
    
    best_time_to_visit = models.TextField(blank=True, null=True, verbose_name='æœ€ä½³æ—…è¡Œæ—¶é—´')
    budget_estimate = models.JSONField(default=dict, verbose_name='é¢„ç®—ä¼°ç®—')
    travel_tips = models.JSONField(default=list, verbose_name='æ—…è¡Œè´´å£«')
    
    # è¯¦ç»†æ”»ç•¥
    detailed_guide = models.JSONField(default=dict, verbose_name='è¯¦ç»†æ”»ç•¥')
    daily_schedule = models.JSONField(default=list, verbose_name='æ¯æ—¥è¡Œç¨‹')
    activity_timeline = models.JSONField(default=list, verbose_name='æ´»åŠ¨æ—¶é—´çº¿')
    cost_breakdown = models.JSONField(default=dict, verbose_name='è´¹ç”¨æ˜ç»†')
    
    # ä¸ªæ€§åŒ–è®¾ç½®
    travel_style = models.CharField(max_length=50, default='general', verbose_name='æ—…è¡Œé£æ ¼')
    budget_min = models.IntegerField(default=3000, verbose_name='æœ€ä½é¢„ç®—(å…ƒ)')
    budget_max = models.IntegerField(default=8000, verbose_name='æœ€é«˜é¢„ç®—(å…ƒ)')
    budget_amount = models.IntegerField(default=5000, verbose_name='é¢„ç®—é‡‘é¢(å…ƒ)')
    budget_range = models.CharField(max_length=50, default='medium', verbose_name='é¢„ç®—èŒƒå›´')
    travel_duration = models.CharField(max_length=50, default='3-5å¤©', verbose_name='æ—…è¡Œæ—¶é•¿')
    interests = models.JSONField(default=list, verbose_name='å…´è¶£æ ‡ç­¾')
    
    # çŠ¶æ€
    is_favorite = models.BooleanField(default=False, verbose_name='æ˜¯å¦æ”¶è—')
    is_exported = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²å¯¼å‡º')
    
    # ç¼“å­˜ç›¸å…³
    is_cached = models.BooleanField(default=False, verbose_name='æ˜¯å¦ç¼“å­˜æ•°æ®')
    cache_source = models.CharField(max_length=50, blank=True, null=True, verbose_name='ç¼“å­˜æ¥æº')
    cache_expires_at = models.DateTimeField(blank=True, null=True, verbose_name='ç¼“å­˜è¿‡æœŸæ—¶é—´')
    api_used = models.CharField(max_length=50, default='deepseek', verbose_name='ä½¿ç”¨çš„API')
    generation_mode = models.CharField(max_length=20, default='standard', verbose_name='ç”Ÿæˆæ¨¡å¼')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ—…æ¸¸æ”»ç•¥'
        verbose_name_plural = 'æ—…æ¸¸æ”»ç•¥'
    
    def __str__(self):
        return f"{self.user.username} - {self.destination}"
    
    def get_attractions_count(self):
        return len(self.must_visit_attractions)
    
    def get_food_count(self):
        return len(self.food_recommendations)
    
    def get_hidden_gems_count(self):
        return len(self.hidden_gems)
    
    def is_cache_valid(self):
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ"""
        if not self.is_cached or not self.cache_expires_at:
            return False
        from django.utils import timezone
        return timezone.now() < self.cache_expires_at
    
    def get_cache_status(self):
        """è·å–ç¼“å­˜çŠ¶æ€"""
        if not self.is_cached:
            return 'not_cached'
        if self.is_cache_valid():
            return 'valid'
        return 'expired'


class TravelGuideCache(models.Model):
    """æ—…æ¸¸æ”»ç•¥ç¼“å­˜æ¨¡å‹"""
    CACHE_SOURCE_CHOICES = [
        ('standard_api', 'æ ‡å‡†APIç”Ÿæˆ'),
        ('fast_api', 'å¿«é€ŸAPIç”Ÿæˆ'),
        ('cached_data', 'ç¼“å­˜æ•°æ®'),
        ('fallback_data', 'å¤‡ç”¨æ•°æ®'),
    ]
    
    API_SOURCE_CHOICES = [
        ('deepseek', 'DeepSeek API'),
        ('openai', 'OpenAI API'),
        ('claude', 'Claude API'),
        ('gemini', 'Gemini API'),
        ('free_api_1', 'å…è´¹API 1'),
        ('free_api_2', 'å…è´¹API 2'),
        ('free_api_3', 'å…è´¹API 3'),
        ('fallback', 'å¤‡ç”¨æ•°æ®'),
    ]
    
    # ç¼“å­˜é”®ï¼ˆç”¨äºæŸ¥æ‰¾ç›¸åŒæ¡ä»¶çš„æ”»ç•¥ï¼‰
    destination = models.CharField(max_length=200, verbose_name='ç›®çš„åœ°')
    travel_style = models.CharField(max_length=50, verbose_name='æ—…è¡Œé£æ ¼')
    budget_min = models.IntegerField(default=3000, verbose_name='æœ€ä½é¢„ç®—(å…ƒ)')
    budget_max = models.IntegerField(default=8000, verbose_name='æœ€é«˜é¢„ç®—(å…ƒ)')
    budget_amount = models.IntegerField(default=5000, verbose_name='é¢„ç®—é‡‘é¢(å…ƒ)')
    budget_range = models.CharField(max_length=50, verbose_name='é¢„ç®—èŒƒå›´')
    travel_duration = models.CharField(max_length=50, verbose_name='æ—…è¡Œæ—¶é•¿')
    interests_hash = models.CharField(max_length=64, verbose_name='å…´è¶£æ ‡ç­¾å“ˆå¸Œ')
    
    # ç¼“å­˜æ•°æ®
    guide_data = models.JSONField(verbose_name='æ”»ç•¥æ•°æ®')
    api_used = models.CharField(max_length=50, choices=API_SOURCE_CHOICES, verbose_name='ä½¿ç”¨çš„API')
    cache_source = models.CharField(max_length=50, choices=CACHE_SOURCE_CHOICES, verbose_name='ç¼“å­˜æ¥æº')
    
    # ç¼“å­˜å…ƒæ•°æ®
    generation_time = models.FloatField(verbose_name='ç”Ÿæˆæ—¶é—´(ç§’)')
    data_quality_score = models.FloatField(default=0.0, verbose_name='æ•°æ®è´¨é‡è¯„åˆ†')
    usage_count = models.IntegerField(default=0, verbose_name='ä½¿ç”¨æ¬¡æ•°')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    expires_at = models.DateTimeField(verbose_name='è¿‡æœŸæ—¶é—´')
    last_accessed = models.DateTimeField(auto_now=True, verbose_name='æœ€åè®¿é—®æ—¶é—´')
    
    class Meta:
        unique_together = ['destination', 'travel_style', 'budget_min', 'budget_max', 'budget_range', 'travel_duration', 'interests_hash']
        ordering = ['-last_accessed']
        verbose_name = 'æ—…æ¸¸æ”»ç•¥ç¼“å­˜'
        verbose_name_plural = 'æ—…æ¸¸æ”»ç•¥ç¼“å­˜'
        indexes = [
            models.Index(fields=['destination', 'travel_style', 'budget_min', 'budget_max', 'travel_duration']),
            models.Index(fields=['expires_at']),
            models.Index(fields=['api_used']),
        ]
    
    def __str__(self):
        return f"{self.destination} - {self.travel_style} - {self.api_used}"
    
    def is_expired(self):
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ"""
        from django.utils import timezone
        return timezone.now() > self.expires_at
    
    def increment_usage(self):
        """å¢åŠ ä½¿ç”¨æ¬¡æ•°"""
        self.usage_count += 1
        self.save(update_fields=['usage_count', 'last_accessed'])
    
    def get_cache_key(self):
        """è·å–ç¼“å­˜é”®"""
        return f"{self.destination}_{self.travel_style}_{self.budget_min}_{self.budget_max}_{self.travel_duration}_{self.interests_hash}"


class TravelDestination(models.Model):
    """æ—…æ¸¸ç›®çš„åœ°æ¨¡å‹"""
    name = models.CharField(max_length=200, verbose_name='ç›®çš„åœ°åç§°')
    country = models.CharField(max_length=100, verbose_name='å›½å®¶')
    region = models.CharField(max_length=100, blank=True, null=True, verbose_name='åœ°åŒº')
    description = models.TextField(blank=True, null=True, verbose_name='æè¿°')
    image_url = models.URLField(blank=True, null=True, verbose_name='å›¾ç‰‡é“¾æ¥')
    popularity_score = models.FloatField(default=0.0, verbose_name='çƒ­åº¦è¯„åˆ†')
    best_season = models.CharField(max_length=100, blank=True, null=True, verbose_name='æœ€ä½³å­£èŠ‚')
    average_cost = models.CharField(max_length=50, blank=True, null=True, verbose_name='å¹³å‡èŠ±è´¹')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-popularity_score']
        verbose_name = 'æ—…æ¸¸ç›®çš„åœ°'
        verbose_name_plural = 'æ—…æ¸¸ç›®çš„åœ°'
    
    def __str__(self):
        return f"{self.name}, {self.country}"


class TravelReview(models.Model):
    """æ—…æ¸¸æ”»ç•¥è¯„ä»·æ¨¡å‹"""
    travel_guide = models.ForeignKey(TravelGuide, on_delete=models.CASCADE, verbose_name='æ—…æ¸¸æ”»ç•¥')
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)], verbose_name='è¯„åˆ†')
    comment = models.TextField(blank=True, null=True, verbose_name='è¯„ä»·å†…å®¹')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        unique_together = ['travel_guide', 'user']
        ordering = ['-created_at']
        verbose_name = 'æ—…æ¸¸æ”»ç•¥è¯„ä»·'
        verbose_name_plural = 'æ—…æ¸¸æ”»ç•¥è¯„ä»·'
    
    def __str__(self):
        return f"{self.user.username} - {self.travel_guide.destination} - {self.rating}æ˜Ÿ"


class JobSearchRequest(models.Model):
    """è‡ªåŠ¨æ±‚èŒè¯·æ±‚æ¨¡å‹"""
    STATUS_CHOICES = [
        ('pending', 'ç­‰å¾…ä¸­'),
        ('processing', 'å¤„ç†ä¸­'),
        ('completed', 'å·²å®Œæˆ'),
        ('failed', 'å¤±è´¥'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    JOB_TYPE_CHOICES = [
        ('full_time', 'å…¨èŒ'),
        ('part_time', 'å…¼èŒ'),
        ('internship', 'å®ä¹ '),
        ('freelance', 'è‡ªç”±èŒä¸š'),
    ]
    
    EXPERIENCE_CHOICES = [
        ('fresh', 'åº”å±Šç”Ÿ'),
        ('1-3', '1-3å¹´'),
        ('3-5', '3-5å¹´'),
        ('5-10', '5-10å¹´'),
        ('10+', '10å¹´ä»¥ä¸Š'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    job_title = models.CharField(max_length=200, verbose_name='èŒä½åç§°')
    location = models.CharField(max_length=200, verbose_name='å·¥ä½œåœ°ç‚¹')
    min_salary = models.IntegerField(verbose_name='æœ€ä½è–ªèµ„(æœˆè–ª)')
    max_salary = models.IntegerField(verbose_name='æœ€é«˜è–ªèµ„(æœˆè–ª)')
    job_type = models.CharField(max_length=20, choices=JOB_TYPE_CHOICES, default='full_time', verbose_name='å·¥ä½œç±»å‹')
    experience_level = models.CharField(max_length=20, choices=EXPERIENCE_CHOICES, default='1-3', verbose_name='ç»éªŒè¦æ±‚')
    keywords = models.JSONField(default=list, verbose_name='å…³é”®è¯')
    company_size = models.CharField(max_length=50, blank=True, null=True, verbose_name='å…¬å¸è§„æ¨¡')
    industry = models.CharField(max_length=100, blank=True, null=True, verbose_name='è¡Œä¸š')
    education_level = models.CharField(max_length=50, blank=True, null=True, verbose_name='å­¦å†è¦æ±‚')
    
    # è‡ªåŠ¨æŠ•é€’è®¾ç½®
    auto_apply = models.BooleanField(default=True, verbose_name='è‡ªåŠ¨æŠ•é€’')
    max_applications = models.IntegerField(default=50, verbose_name='æœ€å¤§æŠ•é€’æ•°é‡')
    application_interval = models.IntegerField(default=30, verbose_name='æŠ•é€’é—´éš”(ç§’)')
    
    # çŠ¶æ€å’Œç»“æœ
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='çŠ¶æ€')
    total_jobs_found = models.IntegerField(default=0, verbose_name='æ‰¾åˆ°èŒä½æ•°')
    total_applications_sent = models.IntegerField(default=0, verbose_name='æŠ•é€’ç®€å†æ•°')
    success_rate = models.FloatField(default=0.0, verbose_name='æˆåŠŸç‡')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='å®Œæˆæ—¶é—´')
    
    # é”™è¯¯ä¿¡æ¯
    error_message = models.TextField(blank=True, null=True, verbose_name='é”™è¯¯ä¿¡æ¯')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ±‚èŒè¯·æ±‚'
        verbose_name_plural = 'æ±‚èŒè¯·æ±‚'
    
    def __str__(self):
        return f"{self.user.username} - {self.job_title} - {self.location}"
    
    def get_salary_range(self):
        return f"{self.min_salary}K-{self.max_salary}K"
    
    def get_progress_percentage(self):
        if self.max_applications == 0:
            return 0
        return min(100, (self.total_applications_sent / self.max_applications) * 100)


class JobApplication(models.Model):
    """èŒä½ç”³è¯·è®°å½•æ¨¡å‹"""
    STATUS_CHOICES = [
        ('applied', 'å·²æŠ•é€’'),
        ('viewed', 'å·²æŸ¥çœ‹'),
        ('contacted', 'å·²è”ç³»'),
        ('interview', 'é¢è¯•é‚€è¯·'),
        ('rejected', 'å·²æ‹’ç»'),
        ('accepted', 'å·²å½•ç”¨'),
    ]
    
    job_search_request = models.ForeignKey(JobSearchRequest, on_delete=models.CASCADE, related_name='applications', verbose_name='æ±‚èŒè¯·æ±‚')
    job_id = models.CharField(max_length=100, verbose_name='èŒä½ID')
    job_title = models.CharField(max_length=200, verbose_name='èŒä½åç§°')
    company_name = models.CharField(max_length=200, verbose_name='å…¬å¸åç§°')
    company_logo = models.URLField(blank=True, null=True, verbose_name='å…¬å¸Logo')
    location = models.CharField(max_length=200, verbose_name='å·¥ä½œåœ°ç‚¹')
    salary_range = models.CharField(max_length=100, verbose_name='è–ªèµ„èŒƒå›´')
    job_description = models.TextField(blank=True, null=True, verbose_name='èŒä½æè¿°')
    requirements = models.JSONField(default=list, verbose_name='èŒä½è¦æ±‚')
    benefits = models.JSONField(default=list, verbose_name='ç¦åˆ©å¾…é‡')
    
    # ç”³è¯·çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='applied', verbose_name='ç”³è¯·çŠ¶æ€')
    application_time = models.DateTimeField(auto_now_add=True, verbose_name='æŠ•é€’æ—¶é—´')
    response_time = models.DateTimeField(null=True, blank=True, verbose_name='å›å¤æ—¶é—´')
    
    # å¹³å°ä¿¡æ¯
    platform = models.CharField(max_length=50, default='boss', verbose_name='æ‹›è˜å¹³å°')
    job_url = models.URLField(verbose_name='èŒä½é“¾æ¥')
    
    # åŒ¹é…åº¦
    match_score = models.FloatField(default=0.0, verbose_name='åŒ¹é…åº¦è¯„åˆ†')
    match_reasons = models.JSONField(default=list, verbose_name='åŒ¹é…åŸå› ')
    
    # å¤‡æ³¨
    notes = models.TextField(blank=True, null=True, verbose_name='å¤‡æ³¨')
    
    class Meta:
        ordering = ['-application_time']
        verbose_name = 'èŒä½ç”³è¯·'
        verbose_name_plural = 'èŒä½ç”³è¯·'
    
    def __str__(self):
        return f"{self.job_title} - {self.company_name}"
    
    def get_status_color(self):
        status_colors = {
            'applied': 'primary',
            'viewed': 'info',
            'contacted': 'warning',
            'interview': 'success',
            'rejected': 'danger',
            'accepted': 'success',
        }
        return status_colors.get(self.status, 'secondary')


class JobSearchProfile(models.Model):
    """æ±‚èŒè€…èµ„æ–™æ¨¡å‹"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    
    # åŸºæœ¬ä¿¡æ¯
    name = models.CharField(max_length=100, verbose_name='å§“å')
    phone = models.CharField(max_length=20, blank=True, null=True, verbose_name='æ‰‹æœºå·')
    email = models.EmailField(blank=True, null=True, verbose_name='é‚®ç®±')
    avatar = models.ImageField(upload_to='job_profiles/', blank=True, null=True, verbose_name='å¤´åƒ')
    
    # æ±‚èŒä¿¡æ¯
    current_position = models.CharField(max_length=100, blank=True, null=True, verbose_name='å½“å‰èŒä½')
    years_of_experience = models.IntegerField(default=0, verbose_name='å·¥ä½œå¹´é™')
    education_level = models.CharField(max_length=50, blank=True, null=True, verbose_name='æœ€é«˜å­¦å†')
    school = models.CharField(max_length=100, blank=True, null=True, verbose_name='æ¯•ä¸šé™¢æ ¡')
    major = models.CharField(max_length=100, blank=True, null=True, verbose_name='ä¸“ä¸š')
    
    # æŠ€èƒ½å’ŒæœŸæœ›
    skills = models.JSONField(default=list, verbose_name='æŠ€èƒ½æ ‡ç­¾')
    expected_salary_min = models.IntegerField(default=0, verbose_name='æœŸæœ›æœ€ä½è–ªèµ„')
    expected_salary_max = models.IntegerField(default=0, verbose_name='æœŸæœ›æœ€é«˜è–ªèµ„')
    preferred_locations = models.JSONField(default=list, verbose_name='æœŸæœ›å·¥ä½œåœ°ç‚¹')
    preferred_industries = models.JSONField(default=list, verbose_name='æœŸæœ›è¡Œä¸š')
    
    # ç®€å†ä¿¡æ¯
    resume_file = models.FileField(upload_to='resumes/', blank=True, null=True, verbose_name='ç®€å†æ–‡ä»¶')
    resume_text = models.TextField(blank=True, null=True, verbose_name='ç®€å†æ–‡æœ¬')
    
    # å¹³å°è´¦å·
    boss_account = models.CharField(max_length=100, blank=True, null=True, verbose_name='Bossç›´è˜è´¦å·')
    zhilian_account = models.CharField(max_length=100, blank=True, null=True, verbose_name='æ™ºè”æ‹›è˜è´¦å·')
    lagou_account = models.CharField(max_length=100, blank=True, null=True, verbose_name='æ‹‰å‹¾ç½‘è´¦å·')
    
    # è®¾ç½®
    auto_apply_enabled = models.BooleanField(default=True, verbose_name='å¯ç”¨è‡ªåŠ¨æŠ•é€’')
    notification_enabled = models.BooleanField(default=True, verbose_name='å¯ç”¨é€šçŸ¥')
    privacy_level = models.CharField(max_length=20, default='public', verbose_name='éšç§çº§åˆ«')
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_applications = models.IntegerField(default=0, verbose_name='æ€»æŠ•é€’æ•°')
    total_interviews = models.IntegerField(default=0, verbose_name='æ€»é¢è¯•æ•°')
    total_offers = models.IntegerField(default=0, verbose_name='æ€»Offeræ•°')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'æ±‚èŒè€…èµ„æ–™'
        verbose_name_plural = 'æ±‚èŒè€…èµ„æ–™'
    
    def __str__(self):
        return f"{self.user.username} - {self.name}"
    
    def get_expected_salary_range(self):
        if self.expected_salary_min and self.expected_salary_max:
            return f"{self.expected_salary_min}K-{self.expected_salary_max}K"
        return "æœªè®¾ç½®"
    
    def get_success_rate(self):
        if self.total_applications == 0:
            return 0
        return round((self.total_offers / self.total_applications) * 100, 2)


class JobSearchStatistics(models.Model):
    """æ±‚èŒç»Ÿè®¡æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    date = models.DateField(auto_now_add=True, verbose_name='ç»Ÿè®¡æ—¥æœŸ')
    
    # æ¯æ—¥ç»Ÿè®¡
    applications_sent = models.IntegerField(default=0, verbose_name='æŠ•é€’ç®€å†æ•°')
    jobs_viewed = models.IntegerField(default=0, verbose_name='æŸ¥çœ‹èŒä½æ•°')
    interviews_received = models.IntegerField(default=0, verbose_name='æ”¶åˆ°é¢è¯•æ•°')
    offers_received = models.IntegerField(default=0, verbose_name='æ”¶åˆ°Offeræ•°')
    
    # å¹³å°ç»Ÿè®¡
    boss_applications = models.IntegerField(default=0, verbose_name='Bossç›´è˜æŠ•é€’æ•°')
    zhilian_applications = models.IntegerField(default=0, verbose_name='æ™ºè”æ‹›è˜æŠ•é€’æ•°')
    lagou_applications = models.IntegerField(default=0, verbose_name='æ‹‰å‹¾ç½‘æŠ•é€’æ•°')
    
    # æˆåŠŸç‡
    response_rate = models.FloatField(default=0.0, verbose_name='å›å¤ç‡')
    interview_rate = models.FloatField(default=0.0, verbose_name='é¢è¯•ç‡')
    offer_rate = models.FloatField(default=0.0, verbose_name='Offerç‡')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        unique_together = ['user', 'date']
        ordering = ['-date']
        verbose_name = 'æ±‚èŒç»Ÿè®¡'
        verbose_name_plural = 'æ±‚èŒç»Ÿè®¡'
    
    def __str__(self):
        return f"{self.user.username} - {self.date}"


class PDFConversionRecord(models.Model):
    """PDFè½¬æ¢è®°å½•æ¨¡å‹"""
    CONVERSION_TYPE_CHOICES = [
        ('pdf_to_word', 'PDFè½¬Word'),
        ('word_to_pdf', 'Wordè½¬PDF'),
        ('pdf_to_image', 'PDFè½¬å›¾ç‰‡'),
        ('image_to_pdf', 'å›¾ç‰‡è½¬PDF'),
        ('pdf_to_text', 'PDFè½¬æ–‡æœ¬'),
        ('text_to_pdf', 'æ–‡æœ¬è½¬PDF'),
    ]
    
    STATUS_CHOICES = [
        ('success', 'æˆåŠŸ'),
        ('failed', 'å¤±è´¥'),
        ('processing', 'å¤„ç†ä¸­'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    conversion_type = models.CharField(max_length=20, choices=CONVERSION_TYPE_CHOICES, verbose_name='è½¬æ¢ç±»å‹')
    original_filename = models.CharField(max_length=255, verbose_name='åŸå§‹æ–‡ä»¶å')
    output_filename = models.CharField(max_length=255, blank=True, null=True, verbose_name='è¾“å‡ºæ–‡ä»¶å')
    file_size = models.BigIntegerField(default=0, verbose_name='æ–‡ä»¶å¤§å°(å­—èŠ‚)')
    conversion_time = models.FloatField(default=0.0, verbose_name='è½¬æ¢æ—¶é—´(ç§’)')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='processing', verbose_name='è½¬æ¢çŠ¶æ€')
    error_message = models.TextField(blank=True, null=True, verbose_name='é”™è¯¯ä¿¡æ¯')
    download_url = models.URLField(blank=True, null=True, verbose_name='ä¸‹è½½é“¾æ¥')
    satisfaction_rating = models.IntegerField(blank=True, null=True, choices=[(i, i) for i in range(1, 6)], verbose_name='æ»¡æ„åº¦è¯„åˆ†(1-5)')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'PDFè½¬æ¢è®°å½•'
        verbose_name_plural = 'PDFè½¬æ¢è®°å½•'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_conversion_type_display()} - {self.original_filename}"
    
    def get_file_size_display(self):
        """è·å–æ–‡ä»¶å¤§å°çš„å¯è¯»æ ¼å¼"""
        if self.file_size < 1024:
            return f"{self.file_size} B"
        elif self.file_size < 1024 * 1024:
            return f"{self.file_size / 1024:.1f} KB"
        elif self.file_size < 1024 * 1024 * 1024:
            return f"{self.file_size / (1024 * 1024):.1f} MB"
        else:
            return f"{self.file_size / (1024 * 1024 * 1024):.1f} GB"
    
    def get_conversion_time_display(self):
        """è·å–è½¬æ¢æ—¶é—´çš„å¯è¯»æ ¼å¼"""
        if self.conversion_time < 1:
            return f"{self.conversion_time * 1000:.0f}ms"
        else:
            return f"{self.conversion_time:.1f}s"


# å¡”ç½—ç‰Œç›¸å…³æ¨¡å‹å·²ç§»åŠ¨åˆ° tarot_models.py


class FoodRandomizer(models.Model):
    """é£Ÿç‰©éšæœºé€‰æ‹©å™¨æ¨¡å‹"""
    MEAL_TYPE_CHOICES = [
        ('breakfast', 'æ—©é¤'),
        ('lunch', 'åˆé¤'),
        ('dinner', 'æ™šé¤'),
        ('snack', 'å¤œå®µ'),
    ]
    
    CUISINE_CHOICES = [
        ('chinese', 'ä¸­é¤'),
        ('western', 'è¥¿é¤'),
        ('japanese', 'æ—¥æ–™'),
        ('korean', 'éŸ©æ–™'),
        ('thai', 'æ³°é¤'),
        ('indian', 'å°åº¦èœ'),
        ('italian', 'æ„å¤§åˆ©èœ'),
        ('french', 'æ³•é¤'),
        ('mexican', 'å¢¨è¥¿å“¥èœ'),
        ('mixed', 'æ··åˆ'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    meal_type = models.CharField(max_length=20, choices=MEAL_TYPE_CHOICES, verbose_name='é¤ç§')
    cuisine_preference = models.CharField(max_length=20, choices=CUISINE_CHOICES, default='mixed', verbose_name='èœç³»åå¥½')
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦æ´»è·ƒ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'é£Ÿç‰©éšæœºé€‰æ‹©å™¨'
        verbose_name_plural = 'é£Ÿç‰©éšæœºé€‰æ‹©å™¨'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.username} - {self.get_meal_type_display()}"


class FoodItem(models.Model):
    """é£Ÿç‰©é¡¹ç›®æ¨¡å‹"""
    MEAL_TYPE_CHOICES = [
        ('breakfast', 'æ—©é¤'),
        ('lunch', 'åˆé¤'),
        ('dinner', 'æ™šé¤'),
        ('snack', 'å¤œå®µ'),
    ]
    
    CUISINE_CHOICES = [
        ('chinese', 'ä¸­é¤'),
        ('western', 'è¥¿é¤'),
        ('japanese', 'æ—¥æ–™'),
        ('korean', 'éŸ©æ–™'),
        ('thai', 'æ³°é¤'),
        ('indian', 'å°åº¦èœ'),
        ('italian', 'æ„å¤§åˆ©èœ'),
        ('french', 'æ³•é¤'),
        ('mexican', 'å¢¨è¥¿å“¥èœ'),
        ('mixed', 'æ··åˆ'),
    ]
    
    DIFFICULTY_CHOICES = [
        ('easy', 'ç®€å•'),
        ('medium', 'ä¸­ç­‰'),
        ('hard', 'å›°éš¾'),
    ]
    
    name = models.CharField(max_length=200, verbose_name='é£Ÿç‰©åç§°')
    description = models.TextField(blank=True, null=True, verbose_name='æè¿°')
    meal_types = models.JSONField(default=list, verbose_name='é€‚ç”¨é¤ç§')
    cuisine = models.CharField(max_length=20, choices=CUISINE_CHOICES, verbose_name='èœç³»')
    difficulty = models.CharField(max_length=20, choices=DIFFICULTY_CHOICES, default='medium', verbose_name='åˆ¶ä½œéš¾åº¦')
    cooking_time = models.IntegerField(default=30, verbose_name='åˆ¶ä½œæ—¶é—´(åˆ†é’Ÿ)')
    ingredients = models.JSONField(default=list, verbose_name='ä¸»è¦é£Ÿæ')
    tags = models.JSONField(default=list, verbose_name='æ ‡ç­¾')
    image_url = models.URLField(blank=True, null=True, verbose_name='å›¾ç‰‡é“¾æ¥')
    recipe_url = models.URLField(blank=True, null=True, verbose_name='é£Ÿè°±é“¾æ¥')
    popularity_score = models.FloatField(default=0.0, verbose_name='å—æ¬¢è¿åº¦')
    
    # è¥å…»ä¿¡æ¯
    calories = models.IntegerField(default=0, verbose_name='å¡è·¯é‡Œ(åƒå¡)')
    protein = models.FloatField(default=0.0, verbose_name='è›‹ç™½è´¨(å…‹)')
    fat = models.FloatField(default=0.0, verbose_name='è„‚è‚ª(å…‹)')
    carbohydrates = models.FloatField(default=0.0, verbose_name='ç¢³æ°´åŒ–åˆç‰©(å…‹)')
    fiber = models.FloatField(default=0.0, verbose_name='è†³é£Ÿçº¤ç»´(å…‹)')
    sugar = models.FloatField(default=0.0, verbose_name='ç³–åˆ†(å…‹)')
    sodium = models.FloatField(default=0.0, verbose_name='é’ (æ¯«å…‹)')
    
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦å¯ç”¨')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'é£Ÿç‰©é¡¹ç›®'
        verbose_name_plural = 'é£Ÿç‰©é¡¹ç›®'
        ordering = ['-popularity_score', 'name']
    
    def __str__(self):
        return self.name
    
    def get_meal_types_display(self):
        return ', '.join([dict(FoodRandomizer.MEAL_TYPE_CHOICES)[meal_type] for meal_type in self.meal_types])


class FoodRandomizationSession(models.Model):
    """é£Ÿç‰©éšæœºé€‰æ‹©ä¼šè¯æ¨¡å‹"""
    STATUS_CHOICES = [
        ('active', 'è¿›è¡Œä¸­'),
        ('paused', 'å·²æš‚åœ'),
        ('completed', 'å·²å®Œæˆ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    meal_type = models.CharField(max_length=20, choices=FoodRandomizer.MEAL_TYPE_CHOICES, verbose_name='é¤ç§')
    cuisine_preference = models.CharField(max_length=20, choices=FoodRandomizer.CUISINE_CHOICES, verbose_name='èœç³»åå¥½')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active', verbose_name='çŠ¶æ€')
    
    # éšæœºè¿‡ç¨‹æ•°æ®
    animation_duration = models.IntegerField(default=3000, verbose_name='åŠ¨ç”»æ—¶é•¿(æ¯«ç§’)')
    total_cycles = models.IntegerField(default=0, verbose_name='æ€»å¾ªç¯æ¬¡æ•°')
    current_cycle = models.IntegerField(default=0, verbose_name='å½“å‰å¾ªç¯æ¬¡æ•°')
    
    # ç»“æœ
    selected_food = models.ForeignKey(FoodItem, on_delete=models.SET_NULL, null=True, blank=True, verbose_name='é€‰ä¸­çš„é£Ÿç‰©')
    alternative_foods = models.JSONField(default=list, verbose_name='å¤‡é€‰é£Ÿç‰©')
    
    # æ—¶é—´æˆ³
    started_at = models.DateTimeField(auto_now_add=True, verbose_name='å¼€å§‹æ—¶é—´')
    paused_at = models.DateTimeField(null=True, blank=True, verbose_name='æš‚åœæ—¶é—´')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='å®Œæˆæ—¶é—´')
    
    class Meta:
        verbose_name = 'é£Ÿç‰©éšæœºé€‰æ‹©ä¼šè¯'
        verbose_name_plural = 'é£Ÿç‰©éšæœºé€‰æ‹©ä¼šè¯'
        ordering = ['-started_at']
    
    def __str__(self):
        return f"{self.user.username} - {self.get_meal_type_display()} - {self.get_status_display()}"
    
    def get_duration(self):
        if self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        elif self.paused_at:
            return (self.paused_at - self.started_at).total_seconds()
        else:
            return (timezone.now() - self.started_at).total_seconds()


class FoodHistory(models.Model):
    """é£Ÿç‰©é€‰æ‹©å†å²è®°å½•æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    session = models.ForeignKey(FoodRandomizationSession, on_delete=models.CASCADE, verbose_name='éšæœºä¼šè¯')
    food_item = models.ForeignKey(FoodItem, on_delete=models.CASCADE, verbose_name='é£Ÿç‰©é¡¹ç›®')
    meal_type = models.CharField(max_length=20, choices=FoodRandomizer.MEAL_TYPE_CHOICES, verbose_name='é¤ç§')
    rating = models.IntegerField(blank=True, null=True, choices=[(i, i) for i in range(1, 6)], verbose_name='è¯„åˆ†')
    feedback = models.TextField(blank=True, null=True, verbose_name='åé¦ˆ')
    was_cooked = models.BooleanField(default=False, verbose_name='æ˜¯å¦åˆ¶ä½œ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='é€‰æ‹©æ—¶é—´')
    
    class Meta:
        verbose_name = 'é£Ÿç‰©é€‰æ‹©å†å²'
        verbose_name_plural = 'é£Ÿç‰©é€‰æ‹©å†å²'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.username} - {self.food_item.name} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"


class CheckInCalendar(models.Model):
    """æ‰“å¡æ—¥å†æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='checkin_calendars')
    calendar_type = models.CharField(max_length=20, choices=[
        ('fitness', 'å¥èº«'),
        ('diary', 'æ—¥è®°'),
        ('guitar', 'å‰ä»–')
    ])
    date = models.DateField()
    status = models.CharField(max_length=20, choices=[
        ('completed', 'å·²å®Œæˆ'),
        ('skipped', 'è·³è¿‡'),
        ('rest', 'ä¼‘æ¯æ—¥')
    ], default='completed')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ['user', 'calendar_type', 'date']
        ordering = ['-date']

    def __str__(self):
        return f"{self.user.username} - {self.get_calendar_type_display()} - {self.date}"


class CheckInDetail(models.Model):
    """æ‰“å¡è¯¦æƒ…æ¨¡å‹"""
    checkin = models.OneToOneField(CheckInCalendar, on_delete=models.CASCADE, related_name='detail')
    
    # é€šç”¨å­—æ®µ
    duration = models.IntegerField(help_text='æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰', null=True, blank=True)
    intensity = models.CharField(max_length=20, choices=[
        ('low', 'ä½'),
        ('medium', 'ä¸­'),
        ('high', 'é«˜')
    ], null=True, blank=True)
    notes = models.TextField(blank=True)
    
    # å¥èº«ä¸“ç”¨å­—æ®µ
    workout_type = models.CharField(max_length=50, choices=[
        ('strength', 'åŠ›é‡è®­ç»ƒ'),
        ('cardio', 'æœ‰æ°§è®­ç»ƒ'),
        ('yoga', 'ç‘œä¼½'),
        ('hiit', 'é«˜å¼ºåº¦é—´æ­‡'),
        ('flexibility', 'æŸ”éŸ§æ€§è®­ç»ƒ'),
        ('other', 'å…¶ä»–')
    ], null=True, blank=True)
    
    # æ–°å¢å¥èº«å­—æ®µ
    training_parts = models.JSONField(default=list, verbose_name='è®­ç»ƒéƒ¨ä½', help_text='å¦‚ï¼šèƒ¸ã€èƒŒã€è…¿ç­‰')
    feeling_rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)], null=True, blank=True, verbose_name='æ„Ÿå—è¯„åˆ†', help_text='1-5æ˜Ÿè¯„åˆ†')
    is_shared_to_community = models.BooleanField(default=False, verbose_name='æ˜¯å¦åˆ†äº«åˆ°ç¤¾åŒº')
    
    # æ—¥è®°ä¸“ç”¨å­—æ®µ
    mood = models.CharField(max_length=20, choices=[
        ('happy', 'å¼€å¿ƒ'),
        ('sad', 'éš¾è¿‡'),
        ('angry', 'æ„¤æ€’'),
        ('calm', 'å¹³é™'),
        ('excited', 'å…´å¥‹'),
        ('tired', 'ç–²æƒ«'),
        ('other', 'å…¶ä»–')
    ], null=True, blank=True)
    weather = models.CharField(max_length=20, null=True, blank=True)
    
    # å‰ä»–ä¸“ç”¨å­—æ®µ
    practice_type = models.CharField(max_length=50, choices=[
        ('chords', 'å’Œå¼¦ç»ƒä¹ '),
        ('scales', 'éŸ³é˜¶ç»ƒä¹ '),
        ('songs', 'æ­Œæ›²ç»ƒä¹ '),
        ('theory', 'ä¹ç†å­¦ä¹ '),
        ('ear_training', 'å¬åŠ›è®­ç»ƒ'),
        ('other', 'å…¶ä»–')
    ], null=True, blank=True)
    song_name = models.CharField(max_length=100, null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.checkin} - è¯¦æƒ…"


class CheckInStreak(models.Model):
    """è¿ç»­æ‰“å¡è®°å½•æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='checkin_streaks')
    calendar_type = models.CharField(max_length=20, choices=[
        ('fitness', 'å¥èº«'),
        ('diary', 'æ—¥è®°'),
        ('guitar', 'å‰ä»–')
    ])
    current_streak = models.IntegerField(default=0)
    longest_streak = models.IntegerField(default=0)
    last_checkin_date = models.DateField(null=True, blank=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ['user', 'calendar_type']

    def __str__(self):
        return f"{self.user.username} - {self.get_calendar_type_display()} - è¿ç»­{self.current_streak}å¤©"


class CheckInAchievement(models.Model):
    """æ‰“å¡æˆå°±æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='checkin_achievements')
    calendar_type = models.CharField(max_length=20, choices=[
        ('fitness', 'å¥èº«'),
        ('diary', 'æ—¥è®°'),
        ('guitar', 'å‰ä»–')
    ])
    achievement_type = models.CharField(max_length=50, choices=[
        ('streak_7', 'è¿ç»­7å¤©'),
        ('streak_30', 'è¿ç»­30å¤©'),
        ('streak_100', 'è¿ç»­100å¤©'),
        ('total_50', 'æ€»è®¡50æ¬¡'),
        ('total_100', 'æ€»è®¡100æ¬¡'),
        ('total_365', 'æ€»è®¡365æ¬¡'),
        ('monthly_20', 'æœˆåº¦20æ¬¡'),
        ('monthly_25', 'æœˆåº¦25æ¬¡'),
        ('monthly_30', 'æœˆåº¦30æ¬¡')
    ])
    achieved_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        unique_together = ['user', 'calendar_type', 'achievement_type']

    def __str__(self):
        return f"{self.user.username} - {self.get_calendar_type_display()} - {self.get_achievement_type_display()}"


class FoodPhotoBinding(models.Model):
    """é£Ÿç‰©ç…§ç‰‡ç»‘å®šæ¨¡å‹"""
    food_item = models.ForeignKey(FoodItem, on_delete=models.CASCADE, verbose_name='é£Ÿç‰©é¡¹ç›®')
    photo_name = models.CharField(max_length=255, verbose_name='ç…§ç‰‡æ–‡ä»¶å')
    photo_url = models.URLField(verbose_name='ç…§ç‰‡URL')
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='åˆ›å»ºè€…')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦å¯ç”¨')
    
    # ç»‘å®šè´¨é‡è¯„ä¼°
    accuracy_score = models.FloatField(default=0.0, verbose_name='å‡†ç¡®åº¦è¯„åˆ†')
    binding_source = models.CharField(max_length=50, default='manual', verbose_name='ç»‘å®šæ¥æº', choices=[
        ('manual', 'æ‰‹åŠ¨ç»‘å®š'),
        ('auto', 'è‡ªåŠ¨åŒ¹é…'),
        ('ai', 'AIæ¨è'),
    ])
    
    class Meta:
        unique_together = ['food_item', 'photo_name']
        verbose_name = 'é£Ÿç‰©ç…§ç‰‡ç»‘å®š'
        verbose_name_plural = 'é£Ÿç‰©ç…§ç‰‡ç»‘å®š'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.food_item.name} -> {self.photo_name}"


class FoodPhotoBindingHistory(models.Model):
    """é£Ÿç‰©ç…§ç‰‡ç»‘å®šå†å²è®°å½•æ¨¡å‹"""
    ACTION_CHOICES = [
        ('create', 'åˆ›å»ºç»‘å®š'),
        ('update', 'æ›´æ–°ç»‘å®š'),
        ('delete', 'åˆ é™¤ç»‘å®š'),
    ]
    
    binding = models.ForeignKey(FoodPhotoBinding, on_delete=models.CASCADE, related_name='history', verbose_name='ç»‘å®šå…³ç³»')
    action = models.CharField(max_length=20, choices=ACTION_CHOICES, verbose_name='æ“ä½œç±»å‹')
    old_photo_name = models.CharField(max_length=255, blank=True, null=True, verbose_name='æ—§ç…§ç‰‡å')
    new_photo_name = models.CharField(max_length=255, blank=True, null=True, verbose_name='æ–°ç…§ç‰‡å')
    performed_by = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='æ“ä½œè€…')
    performed_at = models.DateTimeField(auto_now_add=True, verbose_name='æ“ä½œæ—¶é—´')
    notes = models.TextField(blank=True, null=True, verbose_name='å¤‡æ³¨')
    
    class Meta:
        verbose_name = 'ç»‘å®šå†å²è®°å½•'
        verbose_name_plural = 'ç»‘å®šå†å²è®°å½•'
        ordering = ['-performed_at']
    
    def __str__(self):
        return f"{self.binding.food_item.name} - {self.get_action_display()} - {self.performed_at.strftime('%Y-%m-%d %H:%M')}"


# MeeSomeone äººé™…æ¡£æ¡ˆç³»ç»Ÿæ¨¡å‹

class RelationshipTag(models.Model):
    """å…³ç³»æ ‡ç­¾æ¨¡å‹"""
    TAG_TYPE_CHOICES = [
        ('predefined', 'é¢„å®šä¹‰æ ‡ç­¾'),
        ('custom', 'è‡ªå®šä¹‰æ ‡ç­¾'),
    ]
    
    name = models.CharField(max_length=50, verbose_name='æ ‡ç­¾åç§°')
    tag_type = models.CharField(max_length=20, choices=TAG_TYPE_CHOICES, default='predefined', verbose_name='æ ‡ç­¾ç±»å‹')
    color = models.CharField(max_length=7, default='#9c27b0', verbose_name='æ ‡ç­¾é¢œè‰²')
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, verbose_name='åˆ›å»ºè€…')
    is_global = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¨å±€æ ‡ç­¾')
    usage_count = models.IntegerField(default=0, verbose_name='ä½¿ç”¨æ¬¡æ•°')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'å…³ç³»æ ‡ç­¾'
        verbose_name_plural = 'å…³ç³»æ ‡ç­¾'
        ordering = ['-usage_count', 'name']
    
    def __str__(self):
        return self.name
    
    def increment_usage(self):
        """å¢åŠ ä½¿ç”¨æ¬¡æ•°"""
        self.usage_count += 1
        self.save(update_fields=['usage_count'])


class PersonProfile(models.Model):
    """äººç‰©æ¡£æ¡ˆæ¨¡å‹"""
    IMPORTANCE_CHOICES = [
        (1, 'â­'),
        (2, 'â­â­'),
        (3, 'â­â­â­'),
        (4, 'â­â­â­â­'),
        (5, 'â­â­â­â­â­'),
    ]
    
    GENDER_CHOICES = [
        ('male', 'ç”·'),
        ('female', 'å¥³'),
        ('other', 'å…¶ä»–'),
        ('unknown', 'æœªçŸ¥'),
    ]
    
    # åŸºç¡€ä¿¡æ¯
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    name = models.CharField(max_length=100, verbose_name='å§“å')
    nickname = models.CharField(max_length=100, blank=True, null=True, verbose_name='æ˜µç§°/å¤‡æ³¨å')
    avatar = models.ImageField(upload_to='lifegraph/avatars/', blank=True, null=True, verbose_name='å¤´åƒ')
    
    # å…³ç³»ä¿¡æ¯
    relationship_tags = models.ManyToManyField(RelationshipTag, blank=True, verbose_name='å…³ç³»æ ‡ç­¾')
    first_met_date = models.DateField(blank=True, null=True, verbose_name='è®¤è¯†æ—¥æœŸ')
    first_met_location = models.CharField(max_length=200, blank=True, null=True, verbose_name='è®¤è¯†åœºæ™¯')
    importance_level = models.IntegerField(choices=IMPORTANCE_CHOICES, default=3, verbose_name='é‡è¦ç¨‹åº¦')
    
    # ä¸ªäººèƒŒæ™¯ä¿¡æ¯
    gender = models.CharField(max_length=20, choices=GENDER_CHOICES, default='unknown', verbose_name='æ€§åˆ«')
    age = models.IntegerField(blank=True, null=True, verbose_name='å¹´é¾„')
    occupation = models.CharField(max_length=100, blank=True, null=True, verbose_name='èŒä¸š')
    company_school = models.CharField(max_length=200, blank=True, null=True, verbose_name='å…¬å¸/å­¦æ ¡')
    hometown = models.CharField(max_length=100, blank=True, null=True, verbose_name='å®¶ä¹¡')
    
    # ç‰¹å¾å’Œå…´è¶£
    appearance_notes = models.TextField(blank=True, null=True, verbose_name='å¤–è²Œç‰¹å¾')
    personality_traits = models.JSONField(default=list, verbose_name='æ€§æ ¼ç‰¹ç‚¹')
    interests_hobbies = models.JSONField(default=list, verbose_name='å…´è¶£çˆ±å¥½')
    habits_phrases = models.TextField(blank=True, null=True, verbose_name='ä¹ æƒ¯/å£å¤´ç¦…')
    
    # é‡è¦æ—¥æœŸ
    birthday = models.DateField(blank=True, null=True, verbose_name='ç”Ÿæ—¥')
    important_dates = models.JSONField(default=dict, verbose_name='é‡è¦æ—¥æœŸ')
    
    # è”ç³»æ–¹å¼ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
    phone = models.CharField(max_length=20, blank=True, null=True, verbose_name='ç”µè¯')
    email = models.EmailField(blank=True, null=True, verbose_name='é‚®ç®±')
    social_accounts = models.JSONField(default=dict, verbose_name='ç¤¾äº¤åª’ä½“è´¦å·')
    
    # å…±åŒå¥½å‹
    mutual_friends = models.ManyToManyField('self', blank=True, symmetrical=False, verbose_name='å…±åŒå¥½å‹')
    
    # ç»Ÿè®¡ä¿¡æ¯
    interaction_count = models.IntegerField(default=0, verbose_name='äº’åŠ¨æ¬¡æ•°')
    last_interaction_date = models.DateField(blank=True, null=True, verbose_name='æœ€åäº’åŠ¨æ—¥æœŸ')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'äººç‰©æ¡£æ¡ˆ'
        verbose_name_plural = 'äººç‰©æ¡£æ¡ˆ'
        ordering = ['-importance_level', '-last_interaction_date', 'name']
        unique_together = ['user', 'name']
    
    def __str__(self):
        display_name = self.nickname if self.nickname else self.name
        return f"{self.user.username} - {display_name}"
    
    def get_age_display(self):
        """è·å–å¹´é¾„æ˜¾ç¤º"""
        if self.age:
            return f"{self.age}å²"
        elif self.birthday:
            from datetime import date
            today = date.today()
            age = today.year - self.birthday.year - ((today.month, today.day) < (self.birthday.month, self.birthday.day))
            return f"{age}å²"
        return "æœªçŸ¥"
    
    def get_relationship_tags_display(self):
        """è·å–å…³ç³»æ ‡ç­¾æ˜¾ç¤º"""
        return ', '.join([tag.name for tag in self.relationship_tags.all()])
    
    def get_days_since_last_interaction(self):
        """è·å–è·ç¦»ä¸Šæ¬¡äº’åŠ¨çš„å¤©æ•°"""
        if not self.last_interaction_date:
            return None
        from datetime import date
        return (date.today() - self.last_interaction_date).days
    
    def increment_interaction_count(self):
        """å¢åŠ äº’åŠ¨æ¬¡æ•°"""
        self.interaction_count += 1
        self.last_interaction_date = timezone.now().date()
        self.save(update_fields=['interaction_count', 'last_interaction_date'])


class Interaction(models.Model):
    """äº’åŠ¨è®°å½•æ¨¡å‹"""
    INTERACTION_TYPE_CHOICES = [
        ('meeting', 'è§é¢'),
        ('phone_call', 'ç”µè¯'),
        ('video_call', 'è§†é¢‘é€šè¯'),
        ('message', 'æ¶ˆæ¯èŠå¤©'),
        ('email', 'é‚®ä»¶'),
        ('social_media', 'ç¤¾äº¤åª’ä½“'),
        ('event', 'å…±åŒæ´»åŠ¨'),
        ('gift', 'é€ç¤¼/æ”¶ç¤¼'),
        ('help', 'äº’ç›¸å¸®åŠ©'),
        ('other', 'å…¶ä»–'),
    ]
    
    MOOD_CHOICES = [
        ('very_happy', 'éå¸¸å¼€å¿ƒ'),
        ('happy', 'å¼€å¿ƒ'),
        ('neutral', 'ä¸€èˆ¬'),
        ('disappointed', 'å¤±æœ›'),
        ('sad', 'éš¾è¿‡'),
        ('angry', 'ç”Ÿæ°”'),
        ('confused', 'å›°æƒ‘'),
        ('excited', 'å…´å¥‹'),
        ('nervous', 'ç´§å¼ '),
        ('grateful', 'æ„Ÿæ¿€'),
    ]
    
    # åŸºç¡€ä¿¡æ¯
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    person = models.ForeignKey(PersonProfile, on_delete=models.CASCADE, related_name='interactions', verbose_name='ç›¸å…³äººç‰©')
    
    # äº’åŠ¨è¯¦æƒ…
    interaction_type = models.CharField(max_length=20, choices=INTERACTION_TYPE_CHOICES, verbose_name='äº’åŠ¨ç±»å‹')
    date = models.DateField(verbose_name='æ—¥æœŸ')
    time = models.TimeField(blank=True, null=True, verbose_name='æ—¶é—´')
    location = models.CharField(max_length=200, blank=True, null=True, verbose_name='åœ°ç‚¹')
    
    # å†…å®¹è®°å½•
    title = models.CharField(max_length=200, verbose_name='æ ‡é¢˜/æ‘˜è¦')
    content = models.TextField(verbose_name='è¯¦ç»†å†…å®¹')
    topics_discussed = models.JSONField(default=list, verbose_name='è®¨è®ºè¯é¢˜')
    agreements_made = models.TextField(blank=True, null=True, verbose_name='è¾¾æˆçš„çº¦å®š/æ‰¿è¯º')
    
    # æƒ…æ„Ÿè®°å½•
    mood = models.CharField(max_length=20, choices=MOOD_CHOICES, blank=True, null=True, verbose_name='å½“æ—¶å¿ƒæƒ…')
    impression_notes = models.TextField(blank=True, null=True, verbose_name='å°è±¡/æ„Ÿå—')
    
    # å‚ä¸äººå‘˜
    other_participants = models.ManyToManyField(PersonProfile, blank=True, related_name='group_interactions', verbose_name='å…¶ä»–å‚ä¸è€…')
    
    # é™„ä»¶
    photos = models.JSONField(default=list, verbose_name='ç›¸å…³ç…§ç‰‡')
    files = models.JSONField(default=list, verbose_name='ç›¸å…³æ–‡ä»¶')
    links = models.JSONField(default=list, verbose_name='ç›¸å…³é“¾æ¥')
    
    # æ ‡ç­¾å’Œåˆ†ç±»
    tags = models.JSONField(default=list, verbose_name='è‡ªå®šä¹‰æ ‡ç­¾')
    is_important = models.BooleanField(default=False, verbose_name='æ˜¯å¦é‡è¦')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'äº’åŠ¨è®°å½•'
        verbose_name_plural = 'äº’åŠ¨è®°å½•'
        ordering = ['-date', '-time', '-created_at']
    
    def __str__(self):
        return f"{self.person.name} - {self.title} - {self.date}"
    
    def get_mood_emoji(self):
        """è·å–å¿ƒæƒ…å¯¹åº”çš„è¡¨æƒ…ç¬¦å·"""
        mood_emojis = {
            'very_happy': 'ğŸ˜„',
            'happy': 'ğŸ˜Š',
            'neutral': 'ğŸ˜',
            'disappointed': 'ğŸ˜',
            'sad': 'ğŸ˜¢',
            'angry': 'ğŸ˜ ',
            'confused': 'ğŸ˜•',
            'excited': 'ğŸ¤©',
            'nervous': 'ğŸ˜°',
            'grateful': 'ğŸ™',
        }
        return mood_emojis.get(self.mood, 'ğŸ˜')
    
    def get_duration_display(self):
        """è·å–æ—¶é•¿æ˜¾ç¤ºï¼ˆå¦‚æœæ˜¯ä¼šé¢ç±»å‹ï¼‰"""
        if self.interaction_type in ['meeting', 'phone_call', 'video_call']:
            # è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æ—¶é•¿å­—æ®µ
            return "å¾…è¡¥å……æ—¶é•¿åŠŸèƒ½"
        return ""


class ImportantMoment(models.Model):
    """é‡è¦æ—¶åˆ»æ¨¡å‹"""
    MOMENT_TYPE_CHOICES = [
        ('first_meeting', 'åˆæ¬¡è§é¢'),
        ('friendship_milestone', 'å‹è°Šé‡Œç¨‹ç¢‘'),
        ('collaboration', 'é‡è¦åˆä½œ'),
        ('conflict_resolution', 'è§£å†³çŸ›ç›¾'),
        ('celebration', 'å…±åŒåº†ç¥'),
        ('farewell', 'å‘Šåˆ«æ—¶åˆ»'),
        ('reunion', 'é‡é€¢'),
        ('achievement', 'å…±åŒæˆå°±'),
        ('crisis_support', 'å±æœºæ”¯æŒ'),
        ('life_change', 'äººç”Ÿè½¬æŠ˜'),
        ('other', 'å…¶ä»–'),
    ]
    
    # åŸºç¡€ä¿¡æ¯
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    person = models.ForeignKey(PersonProfile, on_delete=models.CASCADE, related_name='important_moments', verbose_name='ç›¸å…³äººç‰©')
    related_interaction = models.OneToOneField(Interaction, on_delete=models.CASCADE, blank=True, null=True, verbose_name='å…³è”äº’åŠ¨è®°å½•')
    
    # æ—¶åˆ»è¯¦æƒ…
    moment_type = models.CharField(max_length=30, choices=MOMENT_TYPE_CHOICES, verbose_name='æ—¶åˆ»ç±»å‹')
    title = models.CharField(max_length=200, verbose_name='æ—¶åˆ»æ ‡é¢˜')
    description = models.TextField(verbose_name='è¯¦ç»†æè¿°')
    date = models.DateField(verbose_name='æ—¥æœŸ')
    location = models.CharField(max_length=200, blank=True, null=True, verbose_name='åœ°ç‚¹')
    
    # å¤šåª’ä½“å†…å®¹
    photos = models.JSONField(default=list, verbose_name='ç…§ç‰‡')
    videos = models.JSONField(default=list, verbose_name='è§†é¢‘')
    audio_recordings = models.JSONField(default=list, verbose_name='å½•éŸ³')
    documents = models.JSONField(default=list, verbose_name='æ–‡æ¡£')
    
    # å‚ä¸äººå‘˜
    other_participants = models.ManyToManyField(PersonProfile, blank=True, related_name='shared_moments', verbose_name='å…¶ä»–å‚ä¸è€…')
    
    # æƒ…æ„Ÿè®°å½•
    emotional_impact = models.IntegerField(choices=[(i, i) for i in range(1, 6)], default=3, verbose_name='æƒ…æ„Ÿå½±å“ç¨‹åº¦')
    personal_reflection = models.TextField(blank=True, null=True, verbose_name='ä¸ªäººåæ€')
    
    # æ ‡ç­¾
    tags = models.JSONField(default=list, verbose_name='æ ‡ç­¾')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'é‡è¦æ—¶åˆ»'
        verbose_name_plural = 'é‡è¦æ—¶åˆ»'
        ordering = ['-date', '-created_at']
    
    def __str__(self):
        return f"{self.person.name} - {self.title} - {self.date}"
    
    def get_emotional_impact_stars(self):
        """è·å–æƒ…æ„Ÿå½±å“ç¨‹åº¦æ˜Ÿçº§æ˜¾ç¤º"""
        return 'â­' * self.emotional_impact


class RelationshipStatistics(models.Model):
    """äººé™…å…³ç³»ç»Ÿè®¡æ¨¡å‹"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    
    # åŸºç¡€ç»Ÿè®¡
    total_people = models.IntegerField(default=0, verbose_name='æ€»äººæ•°')
    total_interactions = models.IntegerField(default=0, verbose_name='æ€»äº’åŠ¨æ¬¡æ•°')
    total_moments = models.IntegerField(default=0, verbose_name='é‡è¦æ—¶åˆ»æ•°')
    
    # å…³ç³»åˆ†å¸ƒ
    relationship_distribution = models.JSONField(default=dict, verbose_name='å…³ç³»åˆ†å¸ƒ')
    interaction_frequency = models.JSONField(default=dict, verbose_name='äº’åŠ¨é¢‘ç‡åˆ†å¸ƒ')
    
    # æ´»è·ƒåº¦ç»Ÿè®¡
    active_relationships = models.IntegerField(default=0, verbose_name='æ´»è·ƒå…³ç³»æ•°')
    dormant_relationships = models.IntegerField(default=0, verbose_name='ä¼‘çœ å…³ç³»æ•°')
    
    # æ—¶é—´ç»Ÿè®¡
    weekly_interactions = models.JSONField(default=list, verbose_name='æ¯å‘¨äº’åŠ¨æ•°')
    monthly_interactions = models.JSONField(default=list, verbose_name='æ¯æœˆäº’åŠ¨æ•°')
    
    # æ›´æ–°æ—¶é—´
    last_updated = models.DateTimeField(auto_now=True, verbose_name='æœ€åæ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'äººé™…å…³ç³»ç»Ÿè®¡'
        verbose_name_plural = 'äººé™…å…³ç³»ç»Ÿè®¡'
    
    def __str__(self):
        return f"{self.user.username} - äººé™…å…³ç³»ç»Ÿè®¡"
    
    def calculate_statistics(self):
        """è®¡ç®—ç»Ÿè®¡æ•°æ®"""
        from collections import Counter
        
        # è·å–ç”¨æˆ·çš„æ‰€æœ‰äººç‰©æ¡£æ¡ˆå’Œäº’åŠ¨è®°å½•
        profiles = PersonProfile.objects.filter(user=self.user)
        interactions = Interaction.objects.filter(user=self.user)
        moments = ImportantMoment.objects.filter(user=self.user)
        
        # åŸºç¡€ç»Ÿè®¡
        self.total_people = profiles.count()
        self.total_interactions = interactions.count()
        self.total_moments = moments.count()
        
        # å…³ç³»åˆ†å¸ƒç»Ÿè®¡
        relationship_tags = []
        for profile in profiles:
            relationship_tags.extend([tag.name for tag in profile.relationship_tags.all()])
        self.relationship_distribution = dict(Counter(relationship_tags))
        
        # äº’åŠ¨é¢‘ç‡åˆ†å¸ƒ
        interaction_types = [interaction.interaction_type for interaction in interactions]
        self.interaction_frequency = dict(Counter(interaction_types))
        
        # æ´»è·ƒåº¦ç»Ÿè®¡ï¼ˆ30å¤©å†…æœ‰äº’åŠ¨çš„ä¸ºæ´»è·ƒï¼‰
        from datetime import date, timedelta
        thirty_days_ago = date.today() - timedelta(days=30)
        
        self.active_relationships = profiles.filter(
            last_interaction_date__gte=thirty_days_ago
        ).count()
        self.dormant_relationships = self.total_people - self.active_relationships
        
        self.save()


class RelationshipReminder(models.Model):
    """äººé™…å…³ç³»æé†’æ¨¡å‹"""
    REMINDER_TYPE_CHOICES = [
        ('birthday', 'ç”Ÿæ—¥æé†’'),
        ('anniversary', 'çºªå¿µæ—¥æé†’'),
        ('contact', 'è”ç³»æé†’'),
        ('follow_up', 'è·Ÿè¿›æé†’'),
        ('custom', 'è‡ªå®šä¹‰æé†’'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'æ´»è·ƒ'),
        ('completed', 'å·²å®Œæˆ'),
        ('snoozed', 'å·²æ¨è¿Ÿ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    person = models.ForeignKey(PersonProfile, on_delete=models.CASCADE, related_name='reminders', verbose_name='ç›¸å…³äººç‰©')
    
    reminder_type = models.CharField(max_length=20, choices=REMINDER_TYPE_CHOICES, verbose_name='æé†’ç±»å‹')
    title = models.CharField(max_length=200, verbose_name='æé†’æ ‡é¢˜')
    description = models.TextField(blank=True, null=True, verbose_name='æé†’æè¿°')
    
    reminder_date = models.DateField(verbose_name='æé†’æ—¥æœŸ')
    reminder_time = models.TimeField(default='09:00', verbose_name='æé†’æ—¶é—´')
    
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active', verbose_name='çŠ¶æ€')
    is_recurring = models.BooleanField(default=False, verbose_name='æ˜¯å¦é‡å¤')
    recurrence_pattern = models.CharField(max_length=50, blank=True, null=True, verbose_name='é‡å¤æ¨¡å¼')
    
    # æ¨è¿Ÿè®¾ç½®
    snooze_count = models.IntegerField(default=0, verbose_name='æ¨è¿Ÿæ¬¡æ•°')
    max_snooze = models.IntegerField(default=3, verbose_name='æœ€å¤§æ¨è¿Ÿæ¬¡æ•°')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    completed_at = models.DateTimeField(blank=True, null=True, verbose_name='å®Œæˆæ—¶é—´')
    
    class Meta:
        verbose_name = 'äººé™…å…³ç³»æé†’'
        verbose_name_plural = 'äººé™…å…³ç³»æé†’'
        ordering = ['reminder_date', 'reminder_time']
    
    def __str__(self):
        return f"{self.person.name} - {self.title} - {self.reminder_date}"
    
    def can_snooze(self):
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¨è¿Ÿ"""
        return self.snooze_count < self.max_snooze
    
    def snooze_reminder(self, days=1):
        """æ¨è¿Ÿæé†’"""
        if self.can_snooze():
            from datetime import timedelta
            self.reminder_date += timedelta(days=days)
            self.snooze_count += 1
            self.status = 'snoozed'
            self.save()
            return True
        return False


# ===== åŠŸèƒ½æ¨èç³»ç»Ÿæ¨¡å‹ =====

class Feature(models.Model):
    """åŠŸèƒ½æ¨¡å‹ - è®°å½•ç³»ç»Ÿä¸­çš„æ‰€æœ‰åŠŸèƒ½"""
    FEATURE_TYPE_CHOICES = [
        ('tool', 'å·¥å…·åŠŸèƒ½'),
        ('mode', 'æ¨¡å¼åŠŸèƒ½'),
        ('page', 'é¡µé¢åŠŸèƒ½'),
        ('api', 'APIåŠŸèƒ½'),
    ]
    
    CATEGORY_CHOICES = [
        ('work', 'å·¥ä½œæ•ˆç‡'),
        ('life', 'ç”Ÿæ´»å¨±ä¹'),
        ('health', 'å¥åº·ç®¡ç†'),
        ('social', 'ç¤¾äº¤äº’åŠ¨'),
        ('creative', 'åˆ›ä½œå·¥å…·'),
        ('analysis', 'æ•°æ®åˆ†æ'),
        ('entertainment', 'å¨±ä¹ä¼‘é—²'),
        ('learning', 'å­¦ä¹ æˆé•¿'),
        ('other', 'å…¶ä»–'),
    ]
    
    name = models.CharField(max_length=100, verbose_name='åŠŸèƒ½åç§°')
    description = models.TextField(verbose_name='åŠŸèƒ½æè¿°')
    feature_type = models.CharField(max_length=20, choices=FEATURE_TYPE_CHOICES, verbose_name='åŠŸèƒ½ç±»å‹')
    category = models.CharField(max_length=20, choices=CATEGORY_CHOICES, verbose_name='åŠŸèƒ½åˆ†ç±»')
    url_name = models.CharField(max_length=100, verbose_name='URLåç§°', help_text='Django URL name')
    icon_class = models.CharField(max_length=100, verbose_name='å›¾æ ‡ç±»å', help_text='Font Awesomeå›¾æ ‡ç±»å')
    icon_color = models.CharField(max_length=20, default='#007bff', verbose_name='å›¾æ ‡é¢œè‰²')
    
    # æƒé™å’Œå¯è§æ€§
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦å¯ç”¨')
    is_public = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¬å¼€')
    require_login = models.BooleanField(default=True, verbose_name='æ˜¯å¦éœ€è¦ç™»å½•')
    require_membership = models.CharField(max_length=20, choices=[
        ('', 'æ— è¦æ±‚'),
        ('basic', 'åŸºç¡€ä¼šå‘˜'),
        ('premium', 'é«˜çº§ä¼šå‘˜'),
        ('vip', 'VIPä¼šå‘˜'),
    ], blank=True, verbose_name='ä¼šå‘˜è¦æ±‚')
    
    # æ¨èæƒé‡
    recommendation_weight = models.IntegerField(default=50, verbose_name='æ¨èæƒé‡', help_text='1-100ï¼Œæ•°å€¼è¶Šé«˜æ¨èæ¦‚ç‡è¶Šå¤§')
    popularity_score = models.IntegerField(default=0, verbose_name='å—æ¬¢è¿ç¨‹åº¦', help_text='åŸºäºä½¿ç”¨é‡è‡ªåŠ¨è®¡ç®—')
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_usage_count = models.IntegerField(default=0, verbose_name='æ€»ä½¿ç”¨æ¬¡æ•°')
    monthly_usage_count = models.IntegerField(default=0, verbose_name='æœˆä½¿ç”¨æ¬¡æ•°')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'åŠŸèƒ½'
        verbose_name_plural = 'åŠŸèƒ½ç®¡ç†'
        ordering = ['-recommendation_weight', '-popularity_score', 'name']
        indexes = [
            models.Index(fields=['is_active', 'is_public']),
            models.Index(fields=['category', 'feature_type']),
            models.Index(fields=['recommendation_weight', 'popularity_score']),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.get_feature_type_display()})"
    
    def can_recommend_to_user(self, user):
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘ç”¨æˆ·æ¨èæ­¤åŠŸèƒ½"""
        if not self.is_active or not self.is_public:
            return False
        
        if self.require_login and not user.is_authenticated:
            return False
            
        if self.require_membership:
            try:
                membership = user.membership
                if not membership.is_valid:
                    return False
                    
                membership_levels = {'basic': 1, 'premium': 2, 'vip': 3}
                required_level = membership_levels.get(self.require_membership, 0)
                user_level = membership_levels.get(membership.membership_type, 0)
                
                if user_level < required_level:
                    return False
            except:
                return False
        
        return True
    
    def increment_usage(self):
        """å¢åŠ ä½¿ç”¨è®¡æ•°"""
        self.total_usage_count += 1
        self.monthly_usage_count += 1
        # ç®€å•çš„å—æ¬¢è¿ç¨‹åº¦è®¡ç®—
        self.popularity_score = min(100, self.monthly_usage_count // 10)
        self.save(update_fields=['total_usage_count', 'monthly_usage_count', 'popularity_score'])


class UserFeaturePermission(models.Model):
    """ç”¨æˆ·åŠŸèƒ½æƒé™æ¨¡å‹ - ç®¡ç†å‘˜å¯ä»¥æ§åˆ¶ç”¨æˆ·èƒ½çœ‹åˆ°ä»€ä¹ˆåŠŸèƒ½"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    feature = models.ForeignKey(Feature, on_delete=models.CASCADE, verbose_name='åŠŸèƒ½')
    is_visible = models.BooleanField(default=True, verbose_name='æ˜¯å¦å¯è§')
    is_allowed = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…è®¸ä½¿ç”¨')
    custom_weight = models.IntegerField(null=True, blank=True, verbose_name='è‡ªå®šä¹‰æ¨èæƒé‡',
                                      help_text='ä¸ºç‰¹å®šç”¨æˆ·è®¾ç½®çš„æ¨èæƒé‡ï¼Œä¸ºç©ºåˆ™ä½¿ç”¨åŠŸèƒ½é»˜è®¤æƒé‡')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, 
                                 related_name='created_permissions', verbose_name='åˆ›å»ºè€…')
    
    class Meta:
        verbose_name = 'ç”¨æˆ·åŠŸèƒ½æƒé™'
        verbose_name_plural = 'ç”¨æˆ·åŠŸèƒ½æƒé™'
        unique_together = ['user', 'feature']
        indexes = [
            models.Index(fields=['user', 'is_visible', 'is_allowed']),
            models.Index(fields=['feature', 'is_visible']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.feature.name} ({'å¯è§' if self.is_visible else 'éšè—'})"


class FeatureRecommendation(models.Model):
    """åŠŸèƒ½æ¨èè®°å½•æ¨¡å‹"""
    ACTION_CHOICES = [
        ('shown', 'å·²å±•ç¤º'),
        ('clicked', 'å·²ç‚¹å‡»'),
        ('dismissed', 'å·²å¿½ç•¥'),
        ('not_interested', 'ä¸æ„Ÿå…´è¶£'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    feature = models.ForeignKey(Feature, on_delete=models.CASCADE, verbose_name='æ¨èåŠŸèƒ½')
    session_id = models.CharField(max_length=100, verbose_name='ä¼šè¯ID', help_text='ç”¨äºæ ‡è¯†åŒä¸€æ¬¡æ¨èä¼šè¯')
    action = models.CharField(max_length=20, choices=ACTION_CHOICES, verbose_name='ç”¨æˆ·è¡Œä¸º')
    
    # æ¨èä¸Šä¸‹æ–‡ä¿¡æ¯
    recommendation_reason = models.CharField(max_length=200, blank=True, verbose_name='æ¨èç†ç”±')
    user_mode_preference = models.CharField(max_length=20, blank=True, verbose_name='ç”¨æˆ·æ¨¡å¼åå¥½')
    recommendation_algorithm = models.CharField(max_length=50, default='random', verbose_name='æ¨èç®—æ³•')
    
    # æ—¶é—´ä¿¡æ¯
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='æ¨èæ—¶é—´')
    action_time = models.DateTimeField(null=True, blank=True, verbose_name='è¡Œä¸ºæ—¶é—´')
    
    # è®¾å¤‡å’Œç¯å¢ƒä¿¡æ¯
    ip_address = models.GenericIPAddressField(null=True, blank=True, verbose_name='IPåœ°å€')
    user_agent = models.TextField(blank=True, verbose_name='ç”¨æˆ·ä»£ç†')
    
    class Meta:
        verbose_name = 'åŠŸèƒ½æ¨èè®°å½•'
        verbose_name_plural = 'åŠŸèƒ½æ¨èè®°å½•'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['feature', 'action']),
            models.Index(fields=['session_id']),
            models.Index(fields=['action', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.username} - {self.feature.name} - {self.get_action_display()}"
    
    @classmethod
    def get_user_recommendation_history(cls, user, days=30):
        """è·å–ç”¨æˆ·æœ€è¿‘çš„æ¨èå†å²"""
        from datetime import datetime, timedelta
        since = timezone.now() - timedelta(days=days)
        return cls.objects.filter(user=user, created_at__gte=since)
    
    @classmethod
    def has_recent_recommendation(cls, user, feature, hours=24):
        """æ£€æŸ¥æœ€è¿‘æ˜¯å¦å·²ç»æ¨èè¿‡è¯¥åŠŸèƒ½"""
        from datetime import timedelta
        since = timezone.now() - timedelta(hours=hours)
        return cls.objects.filter(user=user, feature=feature, created_at__gte=since).exists()


class UserFirstVisit(models.Model):
    """ç”¨æˆ·é¦–æ¬¡è®¿é—®è®°å½•"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    first_visit_time = models.DateTimeField(auto_now_add=True, verbose_name='é¦–æ¬¡è®¿é—®æ—¶é—´')
    has_seen_recommendation = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²çœ‹è¿‡æ¨è')
    recommendation_shown_count = models.IntegerField(default=0, verbose_name='æ¨èå±•ç¤ºæ¬¡æ•°')
    last_recommendation_time = models.DateTimeField(null=True, blank=True, verbose_name='æœ€åæ¨èæ—¶é—´')
    
    # ç”¨æˆ·è¡Œä¸ºç»Ÿè®¡
    total_login_count = models.IntegerField(default=1, verbose_name='æ€»ç™»å½•æ¬¡æ•°')
    total_feature_usage = models.IntegerField(default=0, verbose_name='æ€»åŠŸèƒ½ä½¿ç”¨æ¬¡æ•°')
    
    class Meta:
        verbose_name = 'ç”¨æˆ·é¦–æ¬¡è®¿é—®è®°å½•'
        verbose_name_plural = 'ç”¨æˆ·é¦–æ¬¡è®¿é—®è®°å½•'
    
    def __str__(self):
        return f"{self.user.username} - é¦–æ¬¡è®¿é—®: {self.first_visit_time}"
    
    def should_show_recommendation(self):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥æ˜¾ç¤ºæ¨è - æ¯æ—¥åªæ˜¾ç¤ºä¸€æ¬¡"""
        # æ–°ç”¨æˆ·é¦–æ¬¡è®¿é—®ï¼Œæ˜¾ç¤ºæ¨è
        if not self.has_seen_recommendation:
            return True
        
        # æ£€æŸ¥æ˜¯å¦ä»Šå¤©å·²ç»æ˜¾ç¤ºè¿‡æ¨è
        if self.last_recommendation_time:
            from datetime import date
            today = date.today()
            last_recommendation_date = self.last_recommendation_time.date()
            
            # å¦‚æœä»Šå¤©å·²ç»æ˜¾ç¤ºè¿‡æ¨èï¼Œåˆ™ä¸å†æ˜¾ç¤º
            if last_recommendation_date == today:
                return False
            
            # å¦‚æœä¸æ˜¯ä»Šå¤©æ˜¾ç¤ºçš„ï¼Œåˆ™å¯ä»¥æ˜¾ç¤ºï¼ˆæ¯æ—¥ä¸€æ¬¡ï¼‰
            return True
        
        # å¦‚æœä»æœªæ˜¾ç¤ºè¿‡æ¨èï¼Œåˆ™æ˜¾ç¤º
        return True
    
    def mark_recommendation_shown(self):
        """æ ‡è®°å·²æ˜¾ç¤ºæ¨è"""
        self.has_seen_recommendation = True
        self.recommendation_shown_count += 1
        self.last_recommendation_time = timezone.now()
        self.save(update_fields=['has_seen_recommendation', 'recommendation_shown_count', 'last_recommendation_time'])


# å¥èº«ç¤¾åŒºç›¸å…³æ¨¡å‹
class FitnessCommunityPost(models.Model):
    """å¥èº«ç¤¾åŒºå¸–å­æ¨¡å‹"""
    POST_TYPE_CHOICES = [
        ('checkin', 'æ‰“å¡åˆ†äº«'),
        ('plan', 'è®­ç»ƒè®¡åˆ’'),
        ('video', 'è®­ç»ƒè§†é¢‘'),
        ('achievement', 'æˆå°±åˆ†äº«'),
        ('motivation', 'åŠ±å¿—åˆ†äº«'),
        ('question', 'é—®é¢˜è®¨è®º'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='å‘å¸ƒç”¨æˆ·')
    post_type = models.CharField(max_length=20, choices=POST_TYPE_CHOICES, verbose_name='å¸–å­ç±»å‹')
    title = models.CharField(max_length=200, verbose_name='æ ‡é¢˜')
    content = models.TextField(verbose_name='å†…å®¹')
    
    # å…³è”çš„æ‰“å¡è®°å½•
    related_checkin = models.ForeignKey(CheckInCalendar, on_delete=models.SET_NULL, null=True, blank=True, verbose_name='å…³è”æ‰“å¡')
    
    # è®­ç»ƒè®¡åˆ’ç›¸å…³
    training_plan_data = models.JSONField(default=dict, blank=True, verbose_name='è®­ç»ƒè®¡åˆ’æ•°æ®')
    
    # è§†é¢‘ç›¸å…³
    video_url = models.URLField(blank=True, null=True, verbose_name='è§†é¢‘é“¾æ¥')
    video_thumbnail = models.ImageField(upload_to='fitness_videos/thumbnails/', blank=True, null=True, verbose_name='è§†é¢‘ç¼©ç•¥å›¾')
    video_duration = models.IntegerField(blank=True, null=True, verbose_name='è§†é¢‘æ—¶é•¿(ç§’)')
    
    # æ ‡ç­¾å’Œåˆ†ç±»
    tags = models.JSONField(default=list, verbose_name='æ ‡ç­¾')
    training_parts = models.JSONField(default=list, verbose_name='è®­ç»ƒéƒ¨ä½')
    difficulty_level = models.CharField(max_length=20, choices=[
        ('beginner', 'åˆçº§'),
        ('intermediate', 'ä¸­çº§'),
        ('advanced', 'é«˜çº§'),
        ('expert', 'ä¸“å®¶çº§')
    ], blank=True, null=True, verbose_name='éš¾åº¦ç­‰çº§')
    
    # äº’åŠ¨æ•°æ®
    likes_count = models.IntegerField(default=0, verbose_name='ç‚¹èµæ•°')
    comments_count = models.IntegerField(default=0, verbose_name='è¯„è®ºæ•°')
    shares_count = models.IntegerField(default=0, verbose_name='åˆ†äº«æ•°')
    views_count = models.IntegerField(default=0, verbose_name='æµè§ˆæ•°')
    
    # çŠ¶æ€
    is_public = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¬å¼€')
    is_featured = models.BooleanField(default=False, verbose_name='æ˜¯å¦ç²¾é€‰')
    is_deleted = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²åˆ é™¤')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å‘å¸ƒæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'å¥èº«ç¤¾åŒºå¸–å­'
        verbose_name_plural = 'å¥èº«ç¤¾åŒºå¸–å­'
    
    def __str__(self):
        return f"{self.user.username} - {self.title}"
    
    def increment_views(self):
        """å¢åŠ æµè§ˆæ•°"""
        self.views_count += 1
        self.save(update_fields=['views_count'])
    
    def get_training_parts_display(self):
        """è·å–è®­ç»ƒéƒ¨ä½æ˜¾ç¤ºæ–‡æœ¬"""
        return ', '.join(self.training_parts) if self.training_parts else 'å…¨èº«'


class FitnessCommunityComment(models.Model):
    """å¥èº«ç¤¾åŒºè¯„è®ºæ¨¡å‹"""
    post = models.ForeignKey(FitnessCommunityPost, on_delete=models.CASCADE, related_name='comments', verbose_name='å¸–å­')
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='è¯„è®ºç”¨æˆ·')
    parent_comment = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='replies', verbose_name='çˆ¶è¯„è®º')
    
    content = models.TextField(verbose_name='è¯„è®ºå†…å®¹')
    likes_count = models.IntegerField(default=0, verbose_name='ç‚¹èµæ•°')
    is_deleted = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²åˆ é™¤')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è¯„è®ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'å¥èº«ç¤¾åŒºè¯„è®º'
        verbose_name_plural = 'å¥èº«ç¤¾åŒºè¯„è®º'
    
    def __str__(self):
        return f"{self.user.username} è¯„è®ºäº† {self.post.title}"


class FitnessCommunityLike(models.Model):
    """å¥èº«ç¤¾åŒºç‚¹èµæ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç‚¹èµç”¨æˆ·')
    post = models.ForeignKey(FitnessCommunityPost, on_delete=models.CASCADE, related_name='likes', verbose_name='å¸–å­')
    comment = models.ForeignKey(FitnessCommunityComment, on_delete=models.CASCADE, null=True, blank=True, related_name='likes', verbose_name='è¯„è®º')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='ç‚¹èµæ—¶é—´')
    
    class Meta:
        unique_together = [['user', 'post'], ['user', 'comment']]
        verbose_name = 'å¥èº«ç¤¾åŒºç‚¹èµ'
        verbose_name_plural = 'å¥èº«ç¤¾åŒºç‚¹èµ'
    
    def __str__(self):
        if self.post:
            return f"{self.user.username} ç‚¹èµäº† {self.post.title}"
        else:
            return f"{self.user.username} ç‚¹èµäº†è¯„è®º"


class FitnessUserProfile(models.Model):
    """å¥èº«ç”¨æˆ·æ¡£æ¡ˆæ¨¡å‹"""
    GENDER_CHOICES = [
        ('male', 'ç”·æ€§'),
        ('female', 'å¥³æ€§'),
    ]
    
    GOAL_CHOICES = [
        ('lose_weight', 'å‡è„‚'),
        ('gain_muscle', 'å¢è‚Œ'),
        ('maintain', 'ç»´æŒä½“é‡'),
    ]
    
    ACTIVITY_LEVEL_CHOICES = [
        ('sedentary', 'ä¹…å'),
        ('light', 'è½»åº¦æ´»åŠ¨'),
        ('moderate', 'ä¸­åº¦æ´»åŠ¨'),
        ('high', 'é‡åº¦æ´»åŠ¨'),
    ]
    
    INTENSITY_CHOICES = [
        ('conservative', 'ä¿å®ˆå‹'),
        ('balanced', 'å‡è¡¡å‹'),
        ('aggressive', 'æ¿€è¿›å‹'),
    ]
    
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    age = models.IntegerField(default=25, verbose_name='å¹´é¾„')
    gender = models.CharField(max_length=10, choices=GENDER_CHOICES, default='male', verbose_name='æ€§åˆ«')
    height = models.FloatField(default=170.0, verbose_name='èº«é«˜(cm)')
    weight = models.FloatField(default=70.0, verbose_name='å½“å‰ä½“é‡(kg)')
    body_fat_percentage = models.FloatField(null=True, blank=True, verbose_name='ä½“è„‚ç‡(%)')
    bmr = models.FloatField(null=True, blank=True, verbose_name='åŸºç¡€ä»£è°¢ç‡')
    goal = models.CharField(max_length=20, choices=GOAL_CHOICES, default='maintain', verbose_name='å¥èº«ç›®æ ‡')
    intensity = models.CharField(max_length=20, choices=INTENSITY_CHOICES, default='balanced', verbose_name='ç›®æ ‡å¼ºåº¦')
    activity_level = models.CharField(max_length=20, choices=ACTIVITY_LEVEL_CHOICES, default='moderate', verbose_name='æ—¥å¸¸æ´»åŠ¨é‡')
    dietary_preferences = models.JSONField(default=list, verbose_name='é¥®é£Ÿåå¥½')
    allergies = models.JSONField(default=list, verbose_name='è¿‡æ•é£Ÿç‰©')
    training_days_per_week = models.IntegerField(default=3, verbose_name='æ¯å‘¨è®­ç»ƒå¤©æ•°')
    training_intensity = models.CharField(max_length=20, default='moderate', verbose_name='è®­ç»ƒå¼ºåº¦')
    training_duration = models.IntegerField(default=60, verbose_name='è®­ç»ƒæ—¶é•¿(åˆ†é’Ÿ)')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'å¥èº«ç”¨æˆ·æ¡£æ¡ˆ'
        verbose_name_plural = 'å¥èº«ç”¨æˆ·æ¡£æ¡ˆ'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_goal_display()}"


class DietPlan(models.Model):
    """é¥®é£Ÿè®¡åˆ’æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    start_date = models.DateField(verbose_name='å¼€å§‹æ—¥æœŸ')
    end_date = models.DateField(verbose_name='ç»“æŸæ—¥æœŸ')
    daily_calories = models.IntegerField(verbose_name='æ¯æ—¥æ€»çƒ­é‡')
    protein_goal = models.IntegerField(verbose_name='è›‹ç™½è´¨ç›®æ ‡(g)')
    carbs_goal = models.IntegerField(verbose_name='ç¢³æ°´ç›®æ ‡(g)')
    fat_goal = models.IntegerField(verbose_name='è„‚è‚ªç›®æ ‡(g)')
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦æ¿€æ´»')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'é¥®é£Ÿè®¡åˆ’'
        verbose_name_plural = 'é¥®é£Ÿè®¡åˆ’'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.username} - {self.start_date} åˆ° {self.end_date}"


class Meal(models.Model):
    """é¤é£Ÿæ¨¡å‹"""
    MEAL_TYPE_CHOICES = [
        ('breakfast', 'æ—©é¤'),
        ('lunch', 'åˆé¤'),
        ('dinner', 'æ™šé¤'),
        ('snack', 'åŠ é¤'),
        ('pre_workout', 'è®­ç»ƒå‰'),
        ('post_workout', 'è®­ç»ƒå'),
    ]
    
    plan = models.ForeignKey(DietPlan, on_delete=models.CASCADE, verbose_name='é¥®é£Ÿè®¡åˆ’')
    meal_type = models.CharField(max_length=20, choices=MEAL_TYPE_CHOICES, verbose_name='é¤é£Ÿç±»å‹')
    day_of_week = models.IntegerField(verbose_name='æ˜ŸæœŸå‡ (1-7)')
    description = models.TextField(verbose_name='é¤é£Ÿæè¿°')
    ingredients = models.JSONField(default=list, verbose_name='é£Ÿææ¸…å•')
    calories = models.IntegerField(verbose_name='çƒ­é‡')
    protein = models.FloatField(verbose_name='è›‹ç™½è´¨(g)')
    carbs = models.FloatField(verbose_name='ç¢³æ°´(g)')
    fat = models.FloatField(verbose_name='è„‚è‚ª(g)')
    ideal_time = models.TimeField(null=True, blank=True, verbose_name='ç†æƒ³ç”¨é¤æ—¶é—´')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'é¤é£Ÿ'
        verbose_name_plural = 'é¤é£Ÿ'
        ordering = ['day_of_week', 'meal_type']
    
    def __str__(self):
        return f"{self.plan.user.username} - {self.get_meal_type_display()} - ç¬¬{self.day_of_week}å¤©"


class NutritionReminder(models.Model):
    """è¥å…»æé†’æ¨¡å‹"""
    REMINDER_TYPE_CHOICES = [
        ('meal_time', 'ç”¨é¤æ—¶é—´'),
        ('pre_workout', 'è®­ç»ƒå‰åŠ é¤'),
        ('post_workout', 'è®­ç»ƒåè¡¥å……'),
        ('hydration', 'æ°´åˆ†è¡¥å……'),
        ('meal_log', 'é¤é£Ÿè®°å½•'),
        ('weight_track', 'ä½“é‡è®°å½•'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    reminder_type = models.CharField(max_length=20, choices=REMINDER_TYPE_CHOICES, verbose_name='æé†’ç±»å‹')
    message = models.TextField(verbose_name='æé†’å†…å®¹')
    trigger_time = models.TimeField(null=True, blank=True, verbose_name='è§¦å‘æ—¶é—´')
    trigger_days = models.JSONField(default=list, verbose_name='è§¦å‘æ—¥æœŸ(1-7)')
    is_recurring = models.BooleanField(default=True, verbose_name='æ˜¯å¦é‡å¤')
    is_active = models.BooleanField(default=True, verbose_name='æ˜¯å¦æ¿€æ´»')
    last_sent = models.DateTimeField(null=True, blank=True, verbose_name='æœ€åå‘é€æ—¶é—´')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'è¥å…»æé†’'
        verbose_name_plural = 'è¥å…»æé†’'
        ordering = ['trigger_time']
    
    def __str__(self):
        return f"{self.user.username} - {self.get_reminder_type_display()}"


class MealLog(models.Model):
    """é¤é£Ÿè®°å½•æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    meal = models.ForeignKey(Meal, on_delete=models.CASCADE, verbose_name='è®¡åˆ’é¤é£Ÿ')
    consumed_date = models.DateField(verbose_name='æ¶ˆè´¹æ—¥æœŸ')
    consumed_time = models.TimeField(verbose_name='æ¶ˆè´¹æ—¶é—´')
    actual_calories = models.IntegerField(null=True, blank=True, verbose_name='å®é™…çƒ­é‡')
    actual_protein = models.FloatField(null=True, blank=True, verbose_name='å®é™…è›‹ç™½è´¨')
    actual_carbs = models.FloatField(null=True, blank=True, verbose_name='å®é™…ç¢³æ°´')
    actual_fat = models.FloatField(null=True, blank=True, verbose_name='å®é™…è„‚è‚ª')
    notes = models.TextField(blank=True, verbose_name='å¤‡æ³¨')
    is_completed = models.BooleanField(default=False, verbose_name='æ˜¯å¦å®Œæˆ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'é¤é£Ÿè®°å½•'
        verbose_name_plural = 'é¤é£Ÿè®°å½•'
        ordering = ['-consumed_date', '-consumed_time']
    
    def __str__(self):
        return f"{self.user.username} - {self.meal.get_meal_type_display()} - {self.consumed_date}"


class WeightTracking(models.Model):
    """ä½“é‡è¿½è¸ªæ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    weight = models.FloatField(verbose_name='ä½“é‡(kg)')
    body_fat_percentage = models.FloatField(null=True, blank=True, verbose_name='ä½“è„‚ç‡(%)')
    measurement_date = models.DateField(verbose_name='æµ‹é‡æ—¥æœŸ')
    notes = models.TextField(blank=True, verbose_name='å¤‡æ³¨')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'ä½“é‡è¿½è¸ª'
        verbose_name_plural = 'ä½“é‡è¿½è¸ª'
        ordering = ['-measurement_date']
    
    def __str__(self):
        return f"{self.user.username} - {self.weight}kg - {self.measurement_date}"


class FoodDatabase(models.Model):
    """é£Ÿç‰©æ•°æ®åº“æ¨¡å‹"""
    name = models.CharField(max_length=200, verbose_name='é£Ÿç‰©åç§°')
    category = models.CharField(max_length=100, verbose_name='é£Ÿç‰©ç±»åˆ«')
    calories_per_100g = models.FloatField(verbose_name='æ¯100gçƒ­é‡')
    protein_per_100g = models.FloatField(verbose_name='æ¯100gè›‹ç™½è´¨')
    carbs_per_100g = models.FloatField(verbose_name='æ¯100gç¢³æ°´')
    fat_per_100g = models.FloatField(verbose_name='æ¯100gè„‚è‚ª')
    fiber_per_100g = models.FloatField(default=0, verbose_name='æ¯100gçº¤ç»´')
    is_vegetarian = models.BooleanField(default=False, verbose_name='æ˜¯å¦ç´ é£Ÿ')
    is_gluten_free = models.BooleanField(default=False, verbose_name='æ˜¯å¦æ— éº¸è´¨')
    allergens = models.JSONField(default=list, verbose_name='è¿‡æ•åŸ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'é£Ÿç‰©æ•°æ®åº“'
        verbose_name_plural = 'é£Ÿç‰©æ•°æ®åº“'
        ordering = ['name']
    
    def __str__(self):
        return self.name


class FitnessAchievement(models.Model):
    """å¥èº«æˆå°±æ¨¡å‹"""
    ACHIEVEMENT_TYPE_CHOICES = [
        ('streak', 'è¿ç»­æˆå°±'),
        ('workout', 'è®­ç»ƒæˆå°±'),
        ('social', 'ç¤¾äº¤æˆå°±'),
        ('milestone', 'é‡Œç¨‹ç¢‘æˆå°±'),
        ('special', 'ç‰¹æ®Šæˆå°±'),
    ]
    
    ACHIEVEMENT_LEVEL_CHOICES = [
        ('bronze', 'é“œç‰Œ'),
        ('silver', 'é“¶ç‰Œ'),
        ('gold', 'é‡‘ç‰Œ'),
        ('platinum', 'ç™½é‡‘'),
        ('diamond', 'é’»çŸ³'),
    ]
    
    name = models.CharField(max_length=100, verbose_name='æˆå°±åç§°')
    description = models.TextField(verbose_name='æˆå°±æè¿°')
    achievement_type = models.CharField(max_length=20, choices=ACHIEVEMENT_TYPE_CHOICES, verbose_name='æˆå°±ç±»å‹')
    level = models.CharField(max_length=20, choices=ACHIEVEMENT_LEVEL_CHOICES, verbose_name='æˆå°±ç­‰çº§')
    
    icon = models.CharField(max_length=50, default='fas fa-trophy', verbose_name='æˆå°±å›¾æ ‡')
    color = models.CharField(max_length=7, default='#FFD700', verbose_name='æˆå°±é¢œè‰²')
    
    # è§£é”æ¡ä»¶
    unlock_condition = models.JSONField(default=dict, verbose_name='è§£é”æ¡ä»¶')
    is_auto_unlock = models.BooleanField(default=True, verbose_name='æ˜¯å¦è‡ªåŠ¨è§£é”')
    
    # ç»Ÿè®¡
    total_earned = models.IntegerField(default=0, verbose_name='æ€»è·å¾—æ¬¡æ•°')
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'å¥èº«æˆå°±'
        verbose_name_plural = 'å¥èº«æˆå°±'
        ordering = ['level', 'achievement_type', 'name']
    
    def __str__(self):
        return f"{self.get_level_display()} - {self.name}"


class UserFitnessAchievement(models.Model):
    """ç”¨æˆ·å¥èº«æˆå°±æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    achievement = models.ForeignKey(FitnessAchievement, on_delete=models.CASCADE, verbose_name='æˆå°±')
    earned_at = models.DateTimeField(auto_now_add=True, verbose_name='è·å¾—æ—¶é—´')
    is_shared = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²åˆ†äº«')
    
    class Meta:
        unique_together = ['user', 'achievement']
        verbose_name = 'ç”¨æˆ·å¥èº«æˆå°±'
        verbose_name_plural = 'ç”¨æˆ·å¥èº«æˆå°±'
        ordering = ['-earned_at']
    
    def __str__(self):
        return f"{self.user.username} è·å¾—äº† {self.achievement.name}"


class FitnessFollow(models.Model):
    """å¥èº«å…³æ³¨å…³ç³»æ¨¡å‹"""
    follower = models.ForeignKey(User, on_delete=models.CASCADE, related_name='following_fitness', verbose_name='å…³æ³¨è€…')
    following = models.ForeignKey(User, on_delete=models.CASCADE, related_name='followers_fitness', verbose_name='è¢«å…³æ³¨è€…')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å…³æ³¨æ—¶é—´')
    
    class Meta:
        unique_together = ['follower', 'following']
        verbose_name = 'å¥èº«å…³æ³¨å…³ç³»'
        verbose_name_plural = 'å¥èº«å…³æ³¨å…³ç³»'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.follower.username} å…³æ³¨äº† {self.following.username}"


class TimeCapsule(models.Model):
    """æ—¶å…‰èƒ¶å›Šæ¨¡å‹"""
    CAPSULE_TYPES = [
        ('memory', 'è®°å¿†èƒ¶å›Š'),
        ('wish', 'æ„¿æœ›èƒ¶å›Š'),
        ('secret', 'ç§˜å¯†èƒ¶å›Š'),
    ]
    
    UNLOCK_CONDITIONS = [
        ('time', 'æ—¶é—´è§£é”'),
        ('location', 'ä½ç½®è§£é”'),
        ('event', 'äº‹ä»¶è§£é”'),
    ]
    
    VISIBILITY_CHOICES = [
        ('private', 'ä»…è‡ªå·±'),
        ('public', 'å…¬å¼€åˆ†äº«'),
        ('anonymous', 'åŒ¿ååˆ†äº«'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='time_capsules', db_index=True)
    title = models.CharField(max_length=200, blank=True)
    content = models.TextField()
    emotions = models.JSONField(default=list)  # å­˜å‚¨æƒ…ç»ªç»„åˆ
    location = models.JSONField(null=True, blank=True)  # å­˜å‚¨ä½ç½®ä¿¡æ¯
    weather = models.JSONField(null=True, blank=True)  # å­˜å‚¨å¤©æ°”ä¿¡æ¯
    keywords = models.JSONField(default=list, blank=True)  # å­˜å‚¨AIç”Ÿæˆçš„å…³é”®è¯
    
    # èƒ¶å›Šè®¾ç½®
    capsule_type = models.CharField(max_length=20, choices=CAPSULE_TYPES, default='memory')
    unlock_condition = models.CharField(max_length=20, choices=UNLOCK_CONDITIONS, default='time')
    unlock_time = models.DateTimeField(null=True, blank=True, db_index=True)  # æ·»åŠ ç´¢å¼•
    unlock_location = models.JSONField(null=True, blank=True)  # ä½ç½®è§£é”æ¡ä»¶
    unlock_event = models.CharField(max_length=200, blank=True)  # äº‹ä»¶è§£é”æ¡ä»¶
    
    # å¯è§æ€§è®¾ç½®
    visibility = models.CharField(max_length=20, choices=VISIBILITY_CHOICES, default='private', db_index=True)  # æ·»åŠ ç´¢å¼•
    is_anonymous = models.BooleanField(default=False)
    
    # åª’ä½“æ–‡ä»¶
    images = models.JSONField(default=list, blank=True)  # å­˜å‚¨å›¾ç‰‡URLåˆ—è¡¨
    audio = models.URLField(blank=True)  # éŸ³é¢‘æ–‡ä»¶URL
    
    # çŠ¶æ€
    is_locked = models.BooleanField(default=True)
    is_unlocked = models.BooleanField(default=False)
    unlock_count = models.IntegerField(default=0)  # è¢«è§£é”æ¬¡æ•°
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)  # æ·»åŠ ç´¢å¼•
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ—¶å…‰èƒ¶å›Š'
        verbose_name_plural = 'æ—¶å…‰èƒ¶å›Š'
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['visibility', 'created_at']),
            models.Index(fields=['unlock_time', 'unlock_condition']),
            models.Index(fields=['emotions'], name='timecapsule_emotions_gin'),
        ]
    
    def __str__(self):
        return f"{self.user.username}çš„{self.get_capsule_type_display()} - {self.created_at.strftime('%Y-%m-%d')}"
    
    def can_be_unlocked_by(self, user):
        """æ£€æŸ¥èƒ¶å›Šæ˜¯å¦å¯ä»¥è¢«æŒ‡å®šç”¨æˆ·è§£é”"""
        if self.user == user:
            return True
        
        if self.visibility == 'private':
            return False
        
        # æ£€æŸ¥æ—¶é—´è§£é”æ¡ä»¶
        if self.unlock_condition == 'time' and self.unlock_time:
            return timezone.now() >= self.unlock_time
        
        # æ£€æŸ¥ä½ç½®è§£é”æ¡ä»¶
        if self.unlock_condition == 'location' and self.unlock_location:
            # è¿™é‡Œéœ€è¦å®ç°ä½ç½®è·ç¦»è®¡ç®—
            pass
        
        return False

class CapsuleUnlock(models.Model):
    """èƒ¶å›Šè§£é”è®°å½•"""
    capsule = models.ForeignKey(TimeCapsule, on_delete=models.CASCADE, related_name='unlocks')
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='unlocked_capsules')
    unlocked_at = models.DateTimeField(auto_now_add=True)
    location = models.JSONField(null=True, blank=True)  # è§£é”æ—¶çš„ä½ç½®
    
    class Meta:
        unique_together = ['capsule', 'user']
        ordering = ['-unlocked_at']
        verbose_name = 'èƒ¶å›Šè§£é”è®°å½•'
        verbose_name_plural = 'èƒ¶å›Šè§£é”è®°å½•'
    
    def __str__(self):
        return f"{self.user.username}è§£é”äº†{self.capsule.user.username}çš„èƒ¶å›Š"

class MemoryFragment(models.Model):
    """è®°å¿†ç¢ç‰‡"""
    FRAGMENT_TYPES = [
        ('text', 'æ–‡å­—ç¢ç‰‡'),
        ('image', 'å›¾ç‰‡ç¢ç‰‡'),
        ('audio', 'éŸ³é¢‘ç¢ç‰‡'),
        ('location', 'ä½ç½®ç¢ç‰‡'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='memory_fragments')
    capsule = models.ForeignKey(TimeCapsule, on_delete=models.CASCADE, related_name='fragments')
    fragment_type = models.CharField(max_length=20, choices=FRAGMENT_TYPES)
    content = models.TextField()
    metadata = models.JSONField(default=dict)  # å­˜å‚¨é¢å¤–ä¿¡æ¯
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'è®°å¿†ç¢ç‰‡'
        verbose_name_plural = 'è®°å¿†ç¢ç‰‡'
    
    def __str__(self):
        return f"{self.user.username}çš„{self.get_fragment_type_display()}"

class Achievement(models.Model):
    """æˆå°±ç³»ç»Ÿ"""
    ACHIEVEMENT_TYPES = [
        ('traveler', 'æ—¶å…‰æ—…äºº'),
        ('explorer', 'åŸå¸‚æ¢é™©å®¶'),
        ('prophet', 'é¢„è¨€å®¶'),
        ('collector', 'è®°å¿†æ”¶è—å®¶'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='achievements')
    achievement_type = models.CharField(max_length=20, choices=ACHIEVEMENT_TYPES)
    unlocked_at = models.DateTimeField(auto_now_add=True)
    progress = models.IntegerField(default=0)  # è¿›åº¦å€¼
    
    class Meta:
        unique_together = ['user', 'achievement_type']
        ordering = ['-unlocked_at']
        verbose_name = 'æˆå°±'
        verbose_name_plural = 'æˆå°±'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_achievement_type_display()}"

class ParallelMatch(models.Model):
    """å¹³è¡Œå®‡å®™åŒ¹é…"""
    user1 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='parallel_matches_1')
    user2 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='parallel_matches_2')
    match_date = models.DateField(auto_now_add=True)
    keywords = models.JSONField(default=list)  # åŒ¹é…çš„å…³é”®è¯
    is_active = models.BooleanField(default=True)
    
    class Meta:
        unique_together = ['user1', 'user2', 'match_date']
        ordering = ['-match_date']
        verbose_name = 'å¹³è¡ŒåŒ¹é…'
        verbose_name_plural = 'å¹³è¡ŒåŒ¹é…'
    
    def __str__(self):
        return f"{self.user1.username} â†” {self.user2.username} ({self.match_date})"

class UserGeneratedTravelGuide(models.Model):
    """ç”¨æˆ·ç”Ÿæˆçš„æ—…æ¸¸æ”»ç•¥æ¨¡å‹ - å¥½å¿ƒäººçš„æ”»ç•¥"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='åˆ›å»ºç”¨æˆ·')
    title = models.CharField(max_length=200, verbose_name='æ”»ç•¥æ ‡é¢˜')
    destination = models.CharField(max_length=200, verbose_name='ç›®çš„åœ°')
    content = models.TextField(verbose_name='æ”»ç•¥å†…å®¹')
    summary = models.TextField(blank=True, null=True, verbose_name='æ”»ç•¥æ‘˜è¦')
    
    # æ”»ç•¥åˆ†ç±»
    travel_style = models.CharField(max_length=50, default='general', verbose_name='æ—…è¡Œé£æ ¼')
    budget_range = models.CharField(max_length=50, default='medium', verbose_name='é¢„ç®—èŒƒå›´')
    travel_duration = models.CharField(max_length=50, default='3-5å¤©', verbose_name='æ—…è¡Œæ—¶é•¿')
    interests = models.JSONField(default=list, verbose_name='å…´è¶£æ ‡ç­¾')
    
    # æ–‡ä»¶é™„ä»¶
    attachment = models.FileField(upload_to='travel_guides/', blank=True, null=True, verbose_name='é™„ä»¶')
    attachment_name = models.CharField(max_length=255, blank=True, null=True, verbose_name='é™„ä»¶åç§°')
    
    # ç»Ÿè®¡ä¿¡æ¯
    view_count = models.IntegerField(default=0, verbose_name='æŸ¥çœ‹æ¬¡æ•°')
    download_count = models.IntegerField(default=0, verbose_name='ä¸‹è½½æ¬¡æ•°')
    use_count = models.IntegerField(default=0, verbose_name='ä½¿ç”¨æ¬¡æ•°')
    
    # çŠ¶æ€
    is_public = models.BooleanField(default=True, verbose_name='æ˜¯å¦å…¬å¼€')
    is_featured = models.BooleanField(default=False, verbose_name='æ˜¯å¦æ¨è')
    is_approved = models.BooleanField(default=True, verbose_name='æ˜¯å¦å®¡æ ¸é€šè¿‡')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'ç”¨æˆ·ç”Ÿæˆæ—…æ¸¸æ”»ç•¥'
        verbose_name_plural = 'ç”¨æˆ·ç”Ÿæˆæ—…æ¸¸æ”»ç•¥'
    
    def __str__(self):
        return f"{self.user.username} - {self.title}"
    
    def get_file_extension(self):
        """è·å–æ–‡ä»¶æ‰©å±•å"""
        if self.attachment:
            return self.attachment.name.split('.')[-1].lower()
        return None
    
    def is_downloadable(self):
        """æ£€æŸ¥æ˜¯å¦å¯ä¸‹è½½"""
        return bool(self.attachment)
    
    def increment_view_count(self):
        """å¢åŠ æŸ¥çœ‹æ¬¡æ•°"""
        self.view_count += 1
        self.save(update_fields=['view_count'])
    
    def increment_download_count(self):
        """å¢åŠ ä¸‹è½½æ¬¡æ•°"""
        self.download_count += 1
        self.save(update_fields=['download_count'])
    
    def increment_use_count(self):
        """å¢åŠ ä½¿ç”¨æ¬¡æ•°"""
        self.use_count += 1
        self.save(update_fields=['use_count'])


class TravelGuideUsage(models.Model):
    """æ—…æ¸¸æ”»ç•¥ä½¿ç”¨è®°å½•æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    guide = models.ForeignKey(UserGeneratedTravelGuide, on_delete=models.CASCADE, verbose_name='æ”»ç•¥')
    usage_type = models.CharField(max_length=20, choices=[
        ('view', 'æŸ¥çœ‹'),
        ('download', 'ä¸‹è½½'),
        ('use', 'ä½¿ç”¨'),
    ], verbose_name='ä½¿ç”¨ç±»å‹')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='ä½¿ç”¨æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ”»ç•¥ä½¿ç”¨è®°å½•'
        verbose_name_plural = 'æ”»ç•¥ä½¿ç”¨è®°å½•'
    
    def __str__(self):
        return f"{self.user.username} - {self.guide.title} - {self.get_usage_type_display()}"


# èˆ¹å®ï¼ˆäºŒæ‰‹çº¿ä¸‹äº¤æ˜“ï¼‰ç›¸å…³æ¨¡å‹

class ShipBaoItem(models.Model):
    """èˆ¹å®ç‰©å“æ¨¡å‹"""
    CATEGORY_CHOICES = [
        ('electronics', 'ç”µå­äº§å“'),
        ('clothing', 'æœé¥°é‹åŒ…'),
        ('furniture', 'å®¶å…·å®¶å±…'),
        ('books', 'å›¾ä¹¦éŸ³åƒ'),
        ('sports', 'è¿åŠ¨æˆ·å¤–'),
        ('beauty', 'ç¾å¦†æŠ¤è‚¤'),
        ('toys', 'ç©å…·æ¸¸æˆ'),
        ('food', 'é£Ÿå“é¥®æ–™'),
        ('other', 'å…¶ä»–'),
    ]
    
    CONDITION_CHOICES = [
        (1, '1æ˜Ÿ - å¾ˆæ—§'),
        (2, '2æ˜Ÿ - è¾ƒæ—§'),
        (3, '3æ˜Ÿ - ä¸€èˆ¬'),
        (4, '4æ˜Ÿ - è¾ƒæ–°'),
        (5, '5æ˜Ÿ - å…¨æ–°'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'å‘å¸ƒä¸­'),
        ('reserved', 'äº¤æ˜“ä¸­'),
        ('completed', 'å·²å®Œæˆ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    DELIVERY_CHOICES = [
        ('pickup', 'ä»…è‡ªæ'),
        ('delivery', 'ä»…é€è´§'),
        ('both', 'è‡ªæ/é€è´§'),
    ]
    
    # åŸºç¡€ä¿¡æ¯
    seller = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='å–å®¶')
    title = models.CharField(max_length=200, verbose_name='ç‰©å“æ ‡é¢˜')
    description = models.TextField(verbose_name='ç‰©å“æè¿°')
    category = models.CharField(max_length=20, choices=CATEGORY_CHOICES, verbose_name='åˆ†ç±»')
    price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='ä»·æ ¼(å…ƒ)')
    condition = models.IntegerField(choices=CONDITION_CHOICES, verbose_name='æ–°æ—§ç¨‹åº¦')
    
    # å›¾ç‰‡
    images = models.JSONField(default=list, verbose_name='å›¾ç‰‡URLåˆ—è¡¨')
    
    # äº¤æ˜“è®¾ç½®
    delivery_option = models.CharField(max_length=20, choices=DELIVERY_CHOICES, default='pickup', verbose_name='äº¤æ˜“æ–¹å¼')
    can_bargain = models.BooleanField(default=False, verbose_name='æ˜¯å¦å¯è®®ä»·')
    
    # åœ°ç†ä½ç½®
    location = models.CharField(max_length=200, verbose_name='äº¤æ˜“åœ°ç‚¹')
    latitude = models.FloatField(blank=True, null=True, verbose_name='çº¬åº¦')
    longitude = models.FloatField(blank=True, null=True, verbose_name='ç»åº¦')
    
    # çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='äº¤æ˜“çŠ¶æ€')
    
    # ç»Ÿè®¡ä¿¡æ¯
    view_count = models.IntegerField(default=0, verbose_name='æµè§ˆæ¬¡æ•°')
    favorite_count = models.IntegerField(default=0, verbose_name='æ”¶è—æ¬¡æ•°')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å‘å¸ƒæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'èˆ¹å®ç‰©å“'
        verbose_name_plural = 'èˆ¹å®ç‰©å“'
        indexes = [
            models.Index(fields=['category', 'status']),
            models.Index(fields=['seller', 'status']),
            models.Index(fields=['price']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"{self.seller.username} - {self.title} - Â¥{self.price}"
    
    def get_condition_stars(self):
        """è·å–æ–°æ—§ç¨‹åº¦æ˜Ÿçº§æ˜¾ç¤º"""
        return 'â˜…' * self.condition + 'â˜†' * (5 - self.condition)
    
    def get_main_image(self):
        """è·å–ä¸»å›¾"""
        return self.images[0] if self.images else None
    
    def get_image_count(self):
        """è·å–å›¾ç‰‡æ•°é‡"""
        return len(self.images)


class ShipBaoTransaction(models.Model):
    """èˆ¹å®äº¤æ˜“è®°å½•æ¨¡å‹"""
    STATUS_CHOICES = [
        ('initiated', 'å·²å‘èµ·'),
        ('negotiating', 'åå•†ä¸­'),
        ('meeting_arranged', 'å·²çº¦å®šè§é¢'),
        ('completed', 'å·²å®Œæˆ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    # äº¤æ˜“ä¿¡æ¯
    item = models.ForeignKey(ShipBaoItem, on_delete=models.CASCADE, related_name='transactions', verbose_name='ç‰©å“')
    buyer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='shipbao_purchases', verbose_name='ä¹°å®¶')
    seller = models.ForeignKey(User, on_delete=models.CASCADE, related_name='shipbao_sales', verbose_name='å–å®¶')
    
    # äº¤æ˜“çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='initiated', verbose_name='äº¤æ˜“çŠ¶æ€')
    
    # äº¤æ˜“è¯¦æƒ…
    final_price = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True, verbose_name='æœ€ç»ˆä»·æ ¼')
    meeting_location = models.CharField(max_length=200, blank=True, null=True, verbose_name='è§é¢åœ°ç‚¹')
    meeting_time = models.DateTimeField(blank=True, null=True, verbose_name='è§é¢æ—¶é—´')
    
    # è¯„ä»·
    buyer_rating = models.IntegerField(blank=True, null=True, choices=[(i, i) for i in range(1, 6)], verbose_name='ä¹°å®¶è¯„åˆ†')
    seller_rating = models.IntegerField(blank=True, null=True, choices=[(i, i) for i in range(1, 6)], verbose_name='å–å®¶è¯„åˆ†')
    buyer_comment = models.TextField(blank=True, null=True, verbose_name='ä¹°å®¶è¯„ä»·')
    seller_comment = models.TextField(blank=True, null=True, verbose_name='å–å®¶è¯„ä»·')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å‘èµ·æ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    completed_at = models.DateTimeField(blank=True, null=True, verbose_name='å®Œæˆæ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'èˆ¹å®äº¤æ˜“'
        verbose_name_plural = 'èˆ¹å®äº¤æ˜“'
        unique_together = ['item', 'buyer']
    
    def __str__(self):
        return f"{self.buyer.username} è´­ä¹° {self.item.title}"


class ShipBaoMessage(models.Model):
    """èˆ¹å®ç§ä¿¡æ¨¡å‹"""
    MESSAGE_TYPE_CHOICES = [
        ('text', 'æ–‡æœ¬'),
        ('image', 'å›¾ç‰‡'),
        ('offer', 'æŠ¥ä»·'),
        ('system', 'ç³»ç»Ÿæ¶ˆæ¯'),
    ]
    
    transaction = models.ForeignKey(ShipBaoTransaction, on_delete=models.CASCADE, related_name='messages', verbose_name='äº¤æ˜“')
    sender = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='å‘é€è€…')
    message_type = models.CharField(max_length=20, choices=MESSAGE_TYPE_CHOICES, default='text', verbose_name='æ¶ˆæ¯ç±»å‹')
    content = models.TextField(verbose_name='æ¶ˆæ¯å†…å®¹')
    image_url = models.URLField(blank=True, null=True, verbose_name='å›¾ç‰‡URL')
    offer_price = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True, verbose_name='æŠ¥ä»·é‡‘é¢')
    
    # æ¶ˆæ¯çŠ¶æ€
    is_read = models.BooleanField(default=False, verbose_name='æ˜¯å¦å·²è¯»')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å‘é€æ—¶é—´')
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'èˆ¹å®ç§ä¿¡'
        verbose_name_plural = 'èˆ¹å®ç§ä¿¡'
    
    def __str__(self):
        return f"{self.sender.username}: {self.content[:50]}"


class ShipBaoUserProfile(models.Model):
    """èˆ¹å®ç”¨æˆ·èµ„æ–™æ¨¡å‹"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    
    # å®åè®¤è¯
    is_verified = models.BooleanField(default=False, verbose_name='æ˜¯å¦å®åè®¤è¯')
    real_name = models.CharField(max_length=50, blank=True, null=True, verbose_name='çœŸå®å§“å')
    id_card_number = models.CharField(max_length=18, blank=True, null=True, verbose_name='èº«ä»½è¯å·')
    verification_time = models.DateTimeField(blank=True, null=True, verbose_name='è®¤è¯æ—¶é—´')
    
    # ä¿¡ç”¨è¯„åˆ†
    credit_score = models.IntegerField(default=100, verbose_name='ä¿¡ç”¨è¯„åˆ†')
    total_transactions = models.IntegerField(default=0, verbose_name='æ€»äº¤æ˜“æ•°')
    successful_transactions = models.IntegerField(default=0, verbose_name='æˆåŠŸäº¤æ˜“æ•°')
    
    # ä½ç½®ä¿¡æ¯
    city = models.CharField(max_length=50, blank=True, null=True, verbose_name='æ‰€åœ¨åŸå¸‚')
    district = models.CharField(max_length=50, blank=True, null=True, verbose_name='æ‰€åœ¨åŒºåŸŸ')
    
    # åå¥½è®¾ç½®
    notification_enabled = models.BooleanField(default=True, verbose_name='å¯ç”¨é€šçŸ¥')
    auto_accept_offers = models.BooleanField(default=False, verbose_name='è‡ªåŠ¨æ¥å—æŠ¥ä»·')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'èˆ¹å®ç”¨æˆ·èµ„æ–™'
        verbose_name_plural = 'èˆ¹å®ç”¨æˆ·èµ„æ–™'
    
    def __str__(self):
        return f"{self.user.username} - èˆ¹å®èµ„æ–™"
    
    def get_success_rate(self):
        """è·å–äº¤æ˜“æˆåŠŸç‡"""
        if self.total_transactions == 0:
            return 0
        return round((self.successful_transactions / self.total_transactions) * 100, 1)
    
    def get_credit_level(self):
        """è·å–ä¿¡ç”¨ç­‰çº§"""
        if self.credit_score >= 90:
            return 'ä¼˜ç§€'
        elif self.credit_score >= 80:
            return 'è‰¯å¥½'
        elif self.credit_score >= 70:
            return 'ä¸€èˆ¬'
        else:
            return 'è¾ƒå·®'


class ShipBaoReport(models.Model):
    """èˆ¹å®ä¸¾æŠ¥æ¨¡å‹"""
    REPORT_TYPE_CHOICES = [
        ('fraud', 'æ¬ºè¯ˆè¡Œä¸º'),
        ('fake_info', 'è™šå‡ä¿¡æ¯'),
        ('inappropriate', 'ä¸å½“å†…å®¹'),
        ('harassment', 'éªšæ‰°è¡Œä¸º'),
        ('other', 'å…¶ä»–'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'å¾…å¤„ç†'),
        ('investigating', 'è°ƒæŸ¥ä¸­'),
        ('resolved', 'å·²å¤„ç†'),
        ('dismissed', 'å·²é©³å›'),
    ]
    
    reporter = models.ForeignKey(User, on_delete=models.CASCADE, related_name='shipbao_reports', verbose_name='ä¸¾æŠ¥è€…')
    reported_user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='shipbao_reported', verbose_name='è¢«ä¸¾æŠ¥è€…')
    reported_item = models.ForeignKey(ShipBaoItem, on_delete=models.CASCADE, blank=True, null=True, verbose_name='è¢«ä¸¾æŠ¥ç‰©å“')
    report_type = models.CharField(max_length=20, choices=REPORT_TYPE_CHOICES, verbose_name='ä¸¾æŠ¥ç±»å‹')
    description = models.TextField(verbose_name='ä¸¾æŠ¥æè¿°')
    evidence = models.JSONField(default=list, verbose_name='è¯æ®ææ–™')
    
    # å¤„ç†çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='å¤„ç†çŠ¶æ€')
    admin_notes = models.TextField(blank=True, null=True, verbose_name='ç®¡ç†å‘˜å¤‡æ³¨')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='ä¸¾æŠ¥æ—¶é—´')
    resolved_at = models.DateTimeField(blank=True, null=True, verbose_name='å¤„ç†æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'èˆ¹å®ä¸¾æŠ¥'
        verbose_name_plural = 'èˆ¹å®ä¸¾æŠ¥'
    
    def __str__(self):
        return f"{self.reporter.username} ä¸¾æŠ¥ {self.reported_user.username}"


# æ­å­ï¼ˆåŒåŸæ´»åŠ¨åŒ¹é…ï¼‰ç›¸å…³æ¨¡å‹

class BuddyEvent(models.Model):
    """æ­å­æ´»åŠ¨æ¨¡å‹"""
    EVENT_TYPE_CHOICES = [
        ('meal', 'é¥­æ­'),
        ('sports', 'çƒæ­'),
        ('travel', 'æ—…è¡Œæ­'),
        ('study', 'å­¦ä¹ æ­'),
        ('game', 'æ¸¸æˆæ­'),
        ('movie', 'ç”µå½±æ­'),
        ('shopping', 'è´­ç‰©æ­'),
        ('coffee', 'å’–å•¡æ­'),
        ('other', 'å…¶ä»–'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'æ‹›å‹Ÿä¸­'),
        ('full', 'äººæ•°å·²æ»¡'),
        ('in_progress', 'è¿›è¡Œä¸­'),
        ('completed', 'å·²ç»“æŸ'),
        ('cancelled', 'å·²å–æ¶ˆ'),
    ]
    
    COST_TYPE_CHOICES = [
        ('free', 'å…è´¹'),
        ('aa', 'AAåˆ¶'),
    ]
    
    GENDER_RESTRICTION_CHOICES = [
        ('none', 'ä¸é™'),
        ('male', 'ä»…é™ç”·æ€§'),
        ('female', 'ä»…é™å¥³æ€§'),
    ]
    
    # åŸºç¡€ä¿¡æ¯
    creator = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='å‘èµ·äºº')
    title = models.CharField(max_length=200, verbose_name='æ´»åŠ¨æ ‡é¢˜')
    description = models.TextField(verbose_name='æ´»åŠ¨æè¿°')
    event_type = models.CharField(max_length=20, choices=EVENT_TYPE_CHOICES, verbose_name='æ´»åŠ¨ç±»å‹')
    
    # æ—¶é—´åœ°ç‚¹
    start_time = models.DateTimeField(verbose_name='å¼€å§‹æ—¶é—´')
    end_time = models.DateTimeField(blank=True, null=True, verbose_name='ç»“æŸæ—¶é—´')
    location = models.CharField(max_length=200, verbose_name='æ´»åŠ¨åœ°ç‚¹')
    latitude = models.FloatField(blank=True, null=True, verbose_name='çº¬åº¦')
    longitude = models.FloatField(blank=True, null=True, verbose_name='ç»åº¦')
    
    # äººæ•°å’Œè´¹ç”¨
    max_members = models.IntegerField(default=4, verbose_name='äººæ•°ä¸Šé™')
    cost_type = models.CharField(max_length=20, choices=COST_TYPE_CHOICES, default='aa', verbose_name='è´¹ç”¨ç±»å‹')
    estimated_cost = models.DecimalField(max_digits=10, decimal_places=2, blank=True, null=True, verbose_name='é¢„ä¼°è´¹ç”¨')
    
    # é™åˆ¶æ¡ä»¶
    gender_restriction = models.CharField(max_length=20, choices=GENDER_RESTRICTION_CHOICES, default='none', verbose_name='æ€§åˆ«é™åˆ¶')
    age_min = models.IntegerField(blank=True, null=True, verbose_name='æœ€å°å¹´é¾„')
    age_max = models.IntegerField(blank=True, null=True, verbose_name='æœ€å¤§å¹´é¾„')
    
    # çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active', verbose_name='æ´»åŠ¨çŠ¶æ€')
    
    # ç»Ÿè®¡ä¿¡æ¯
    view_count = models.IntegerField(default=0, verbose_name='æµè§ˆæ¬¡æ•°')
    application_count = models.IntegerField(default=0, verbose_name='ç”³è¯·æ¬¡æ•°')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ­å­æ´»åŠ¨'
        verbose_name_plural = 'æ­å­æ´»åŠ¨'
        indexes = [
            models.Index(fields=['event_type', 'status']),
            models.Index(fields=['creator', 'status']),
            models.Index(fields=['start_time']),
            models.Index(fields=['location']),
        ]
    
    def __str__(self):
        return f"{self.creator.username} - {self.title}"
    
    def get_current_member_count(self):
        """è·å–å½“å‰æˆå‘˜æ•°"""
        return self.members.filter(status='joined').count()
    
    def is_full(self):
        """æ£€æŸ¥æ˜¯å¦å·²æ»¡å‘˜"""
        return self.get_current_member_count() >= self.max_members
    
    def get_time_until_start(self):
        """è·å–è·ç¦»å¼€å§‹æ—¶é—´"""
        from django.utils import timezone
        now = timezone.now()
        if self.start_time > now:
            delta = self.start_time - now
            days = delta.days
            hours = delta.seconds // 3600
            if days > 0:
                return f"{days}å¤©{hours}å°æ—¶"
            else:
                return f"{hours}å°æ—¶"
        return "å·²å¼€å§‹"


class BuddyEventMember(models.Model):
    """æ­å­æ´»åŠ¨æˆå‘˜æ¨¡å‹"""
    STATUS_CHOICES = [
        ('pending', 'å¾…å®¡æ ¸'),
        ('joined', 'å·²åŠ å…¥'),
        ('rejected', 'å·²æ‹’ç»'),
        ('left', 'å·²é€€å‡º'),
    ]
    
    event = models.ForeignKey(BuddyEvent, on_delete=models.CASCADE, related_name='members', verbose_name='æ´»åŠ¨')
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='çŠ¶æ€')
    
    # ç”³è¯·ä¿¡æ¯
    application_message = models.TextField(blank=True, null=True, verbose_name='ç”³è¯·ç•™è¨€')
    
    # æ—¶é—´æˆ³
    applied_at = models.DateTimeField(auto_now_add=True, verbose_name='ç”³è¯·æ—¶é—´')
    joined_at = models.DateTimeField(blank=True, null=True, verbose_name='åŠ å…¥æ—¶é—´')
    
    class Meta:
        unique_together = ['event', 'user']
        ordering = ['applied_at']
        verbose_name = 'æ­å­æ´»åŠ¨æˆå‘˜'
        verbose_name_plural = 'æ­å­æ´»åŠ¨æˆå‘˜'
    
    def __str__(self):
        return f"{self.user.username} - {self.event.title}"


class BuddyEventChat(models.Model):
    """æ­å­æ´»åŠ¨ç¾¤èŠæ¨¡å‹"""
    event = models.OneToOneField(BuddyEvent, on_delete=models.CASCADE, related_name='chat', verbose_name='æ´»åŠ¨')
    is_active = models.BooleanField(default=False, verbose_name='æ˜¯å¦æ´»è·ƒ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    
    class Meta:
        verbose_name = 'æ­å­æ´»åŠ¨ç¾¤èŠ'
        verbose_name_plural = 'æ­å­æ´»åŠ¨ç¾¤èŠ'
    
    def __str__(self):
        return f"{self.event.title} - ç¾¤èŠ"


class BuddyEventMessage(models.Model):
    """æ­å­æ´»åŠ¨ç¾¤èŠæ¶ˆæ¯æ¨¡å‹"""
    MESSAGE_TYPE_CHOICES = [
        ('text', 'æ–‡æœ¬'),
        ('image', 'å›¾ç‰‡'),
        ('system', 'ç³»ç»Ÿæ¶ˆæ¯'),
    ]
    
    chat = models.ForeignKey(BuddyEventChat, on_delete=models.CASCADE, related_name='messages', verbose_name='ç¾¤èŠ')
    sender = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='å‘é€è€…')
    message_type = models.CharField(max_length=20, choices=MESSAGE_TYPE_CHOICES, default='text', verbose_name='æ¶ˆæ¯ç±»å‹')
    content = models.TextField(verbose_name='æ¶ˆæ¯å†…å®¹')
    image_url = models.URLField(blank=True, null=True, verbose_name='å›¾ç‰‡URL')
    
    # æ¶ˆæ¯çŠ¶æ€
    is_read_by = models.ManyToManyField(User, related_name='legacy_buddy_read_messages', blank=True, verbose_name='å·²è¯»ç”¨æˆ·')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='å‘é€æ—¶é—´')
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'æ­å­æ´»åŠ¨æ¶ˆæ¯'
        verbose_name_plural = 'æ­å­æ´»åŠ¨æ¶ˆæ¯'
    
    def __str__(self):
        return f"{self.sender.username}: {self.content[:50]}"


class BuddyUserProfile(models.Model):
    """æ­å­ç”¨æˆ·èµ„æ–™æ¨¡å‹"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    
    # å…´è¶£æ ‡ç­¾
    interests = models.JSONField(default=list, verbose_name='å…´è¶£æ ‡ç­¾')
    
    # ä½ç½®ä¿¡æ¯
    city = models.CharField(max_length=50, blank=True, null=True, verbose_name='æ‰€åœ¨åŸå¸‚')
    district = models.CharField(max_length=50, blank=True, null=True, verbose_name='æ‰€åœ¨åŒºåŸŸ')
    
    # æ´»åŠ¨ç»Ÿè®¡
    created_events = models.IntegerField(default=0, verbose_name='å‘èµ·æ´»åŠ¨æ•°')
    joined_events = models.IntegerField(default=0, verbose_name='å‚ä¸æ´»åŠ¨æ•°')
    total_events = models.IntegerField(default=0, verbose_name='æ€»æ´»åŠ¨æ•°')
    
    # ä¿¡ç”¨è¯„åˆ†
    credit_score = models.IntegerField(default=100, verbose_name='ä¿¡ç”¨è¯„åˆ†')
    no_show_count = models.IntegerField(default=0, verbose_name='çˆ½çº¦æ¬¡æ•°')
    
    # åå¥½è®¾ç½®
    notification_enabled = models.BooleanField(default=True, verbose_name='å¯ç”¨é€šçŸ¥')
    auto_join_enabled = models.BooleanField(default=False, verbose_name='è‡ªåŠ¨åŠ å…¥')
    
    # é»‘åå•
    blacklisted_users = models.ManyToManyField(User, related_name='blacklisted_by', blank=True, verbose_name='é»‘åå•ç”¨æˆ·')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'æ­å­ç”¨æˆ·èµ„æ–™'
        verbose_name_plural = 'æ­å­ç”¨æˆ·èµ„æ–™'
    
    def __str__(self):
        return f"{self.user.username} - æ­å­èµ„æ–™"
    
    def get_activity_rate(self):
        """è·å–æ´»åŠ¨å‚ä¸ç‡"""
        if self.total_events == 0:
            return 0
        return round((self.joined_events / self.total_events) * 100, 1)
    
    def get_credit_level(self):
        """è·å–ä¿¡ç”¨ç­‰çº§"""
        if self.credit_score >= 90:
            return 'ä¼˜ç§€'
        elif self.credit_score >= 80:
            return 'è‰¯å¥½'
        elif self.credit_score >= 70:
            return 'ä¸€èˆ¬'
        else:
            return 'è¾ƒå·®'


class BuddyEventReview(models.Model):
    """æ­å­æ´»åŠ¨è¯„ä»·æ¨¡å‹"""
    event = models.ForeignKey(BuddyEvent, on_delete=models.CASCADE, related_name='reviews', verbose_name='æ´»åŠ¨')
    reviewer = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='è¯„ä»·è€…')
    reviewed_user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='buddy_reviews_received', verbose_name='è¢«è¯„ä»·è€…')
    
    # è¯„ä»·å†…å®¹
    rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)], verbose_name='è¯„åˆ†')
    comment = models.TextField(blank=True, null=True, verbose_name='è¯„ä»·å†…å®¹')
    
    # è¯„ä»·ç»´åº¦
    punctuality = models.IntegerField(choices=[(i, i) for i in range(1, 6)], verbose_name='å®ˆæ—¶ç¨‹åº¦')
    friendliness = models.IntegerField(choices=[(i, i) for i in range(1, 6)], verbose_name='å‹å¥½ç¨‹åº¦')
    participation = models.IntegerField(choices=[(i, i) for i in range(1, 6)], verbose_name='å‚ä¸åº¦')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è¯„ä»·æ—¶é—´')
    
    class Meta:
        unique_together = ['event', 'reviewer', 'reviewed_user']
        ordering = ['-created_at']
        verbose_name = 'æ­å­æ´»åŠ¨è¯„ä»·'
        verbose_name_plural = 'æ­å­æ´»åŠ¨è¯„ä»·'
    
    def __str__(self):
        return f"{self.reviewer.username} è¯„ä»· {self.reviewed_user.username}"


class BuddyEventReport(models.Model):
    """æ­å­æ´»åŠ¨ä¸¾æŠ¥æ¨¡å‹"""
    REPORT_TYPE_CHOICES = [
        ('no_show', 'çˆ½çº¦'),
        ('inappropriate', 'ä¸å½“è¡Œä¸º'),
        ('harassment', 'éªšæ‰°'),
        ('fake_info', 'è™šå‡ä¿¡æ¯'),
        ('other', 'å…¶ä»–'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'å¾…å¤„ç†'),
        ('investigating', 'è°ƒæŸ¥ä¸­'),
        ('resolved', 'å·²å¤„ç†'),
        ('dismissed', 'å·²é©³å›'),
    ]
    
    reporter = models.ForeignKey(User, on_delete=models.CASCADE, related_name='buddy_reports', verbose_name='ä¸¾æŠ¥è€…')
    reported_user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='buddy_reported', verbose_name='è¢«ä¸¾æŠ¥è€…')
    reported_event = models.ForeignKey(BuddyEvent, on_delete=models.CASCADE, blank=True, null=True, verbose_name='ç›¸å…³æ´»åŠ¨')
    report_type = models.CharField(max_length=20, choices=REPORT_TYPE_CHOICES, verbose_name='ä¸¾æŠ¥ç±»å‹')
    description = models.TextField(verbose_name='ä¸¾æŠ¥æè¿°')
    evidence = models.JSONField(default=list, verbose_name='è¯æ®ææ–™')
    
    # å¤„ç†çŠ¶æ€
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='å¤„ç†çŠ¶æ€')
    admin_notes = models.TextField(blank=True, null=True, verbose_name='ç®¡ç†å‘˜å¤‡æ³¨')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='ä¸¾æŠ¥æ—¶é—´')
    resolved_at = models.DateTimeField(blank=True, null=True, verbose_name='å¤„ç†æ—¶é—´')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'æ­å­æ´»åŠ¨ä¸¾æŠ¥'
        verbose_name_plural = 'æ­å­æ´»åŠ¨ä¸¾æŠ¥'
    
    def __str__(self):
        return f"{self.reporter.username} ä¸¾æŠ¥ {self.reported_user.username}"


class ExerciseWeightRecord(models.Model):
    """é”»ç‚¼é‡é‡è®°å½•æ¨¡å‹"""
    EXERCISE_TYPE_CHOICES = [
        # ä¸‰å¤§é¡¹
        ('squat', 'æ·±è¹²'),
        ('bench_press', 'å§æ¨'),
        ('deadlift', 'ç¡¬æ‹‰'),
        # å…¶ä»–åŠ›é‡è®­ç»ƒ
        ('overhead_press', 'æ¨ä¸¾'),
        ('barbell_row', 'æ é“ƒåˆ’èˆ¹'),
        ('pull_up', 'å¼•ä½“å‘ä¸Š'),
        ('dip', 'åŒæ è‡‚å±ˆä¼¸'),
        ('lunge', 'å¼“æ­¥è¹²'),
        ('leg_press', 'è…¿ä¸¾'),
        ('leg_curl', 'è…¿å¼¯ä¸¾'),
        ('leg_extension', 'è…¿ä¼¸å±•'),
        ('calf_raise', 'æè¸µ'),
        ('bicep_curl', 'å¼¯ä¸¾'),
        ('tricep_extension', 'è‡‚å±ˆä¼¸'),
        ('shoulder_press', 'è‚©æ¨'),
        ('lateral_raise', 'ä¾§å¹³ä¸¾'),
        ('rear_delt_fly', 'åä¸‰è§’è‚Œé£é¸Ÿ'),
        ('chest_fly', 'é£é¸Ÿ'),
        ('lat_pulldown', 'é«˜ä½ä¸‹æ‹‰'),
        ('face_pull', 'é¢æ‹‰'),
        ('shrug', 'è€¸è‚©'),
        ('upright_row', 'ç›´ç«‹åˆ’èˆ¹'),
        ('good_morning', 'æ—©å®‰å¼'),
        ('romanian_deadlift', 'ç½—é©¬å°¼äºšç¡¬æ‹‰'),
        ('sumo_deadlift', 'ç›¸æ‰‘ç¡¬æ‹‰'),
        ('front_squat', 'å‰è¹²'),
        ('back_squat', 'åè¹²'),
        ('box_squat', 'ç®±å¼æ·±è¹²'),
        ('pause_squat', 'æš‚åœæ·±è¹²'),
        ('close_grip_bench', 'çª„æ¡å§æ¨'),
        ('wide_grip_bench', 'å®½æ¡å§æ¨'),
        ('incline_bench', 'ä¸Šæ–œå§æ¨'),
        ('decline_bench', 'ä¸‹æ–œå§æ¨'),
        ('dumbbell_bench', 'å“‘é“ƒå§æ¨'),
        ('dumbbell_squat', 'å“‘é“ƒæ·±è¹²'),
        ('goblet_squat', 'é«˜è„šæ¯æ·±è¹²'),
        ('bulgarian_split_squat', 'ä¿åŠ åˆ©äºšåˆ†è…¿è¹²'),
        ('step_up', 'å°é˜¶ä¸Š'),
        ('hip_thrust', 'è‡€æ¡¥'),
        ('glute_bridge', 'è‡€æ¡¥'),
        ('plank', 'å¹³æ¿æ”¯æ’‘'),
        ('side_plank', 'ä¾§å¹³æ¿'),
        ('crunch', 'å·è…¹'),
        ('sit_up', 'ä»°å§èµ·å'),
        ('russian_twist', 'ä¿„ç½—æ–¯è½¬ä½“'),
        ('mountain_climber', 'ç™»å±±è€…'),
        ('burpee', 'æ³¢æ¯”è·³'),
        ('jumping_jack', 'å¼€åˆè·³'),
        ('high_knee', 'é«˜æŠ¬è…¿'),
        ('butt_kick', 'åè¸¢è…¿'),
        ('other', 'å…¶ä»–'),
    ]
    
    REP_TYPE_CHOICES = [
        ('1rm', '1RM'),
        ('3rm', '3RM'),
        ('5rm', '5RM'),
        ('8rm', '8RM'),
        ('10rm', '10RM'),
        ('12rm', '12RM'),
        ('15rm', '15RM'),
        ('20rm', '20RM'),
        ('max_reps', 'æœ€å¤§æ¬¡æ•°'),
        ('custom', 'è‡ªå®šä¹‰'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    exercise_type = models.CharField(max_length=50, choices=EXERCISE_TYPE_CHOICES, verbose_name='é”»ç‚¼ç±»å‹')
    weight = models.FloatField(verbose_name='é‡é‡(kg)')
    reps = models.IntegerField(verbose_name='æ¬¡æ•°')
    rep_type = models.CharField(max_length=10, choices=REP_TYPE_CHOICES, default='custom', verbose_name='æ¬¡æ•°ç±»å‹')
    sets = models.IntegerField(default=1, verbose_name='ç»„æ•°')
    rpe = models.IntegerField(null=True, blank=True, verbose_name='RPE(1-10)')
    notes = models.TextField(blank=True, null=True, verbose_name='å¤‡æ³¨')
    workout_date = models.DateField(verbose_name='è®­ç»ƒæ—¥æœŸ')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='è®°å½•æ—¶é—´')
    
    class Meta:
        ordering = ['-workout_date', '-created_at']
        verbose_name = 'é”»ç‚¼é‡é‡è®°å½•'
        verbose_name_plural = 'é”»ç‚¼é‡é‡è®°å½•'
    
    def __str__(self):
        return f"{self.user.username} - {self.get_exercise_type_display()} - {self.weight}kg x {self.reps}æ¬¡"
    
    def get_estimated_1rm(self):
        """ä¼°ç®—1RM"""
        if self.reps == 1:
            return self.weight
        
        # ä½¿ç”¨Epleyå…¬å¼ä¼°ç®—1RM
        if self.reps <= 10:
            return round(self.weight * (1 + self.reps / 30), 1)
        else:
            # å¯¹äºé«˜æ¬¡æ•°ï¼Œä½¿ç”¨æ›´ä¿å®ˆçš„ä¼°ç®—
            return round(self.weight * (1 + self.reps / 40), 1)
    
    def get_weight_class(self):
        """è·å–é‡é‡ç­‰çº§"""
        if self.exercise_type in ['squat', 'bench_press', 'deadlift']:
            if self.weight < 50:
                return 'åˆå­¦è€…'
            elif self.weight < 100:
                return 'è¿›é˜¶è€…'
            elif self.weight < 150:
                return 'ä¸­çº§è€…'
            elif self.weight < 200:
                return 'é«˜çº§è€…'
            else:
                return 'ä¸“å®¶çº§'
        return 'æ ‡å‡†'


class FitnessStrengthProfile(models.Model):
    """å¥èº«åŠ›é‡æ¡£æ¡ˆæ¨¡å‹"""
    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name='ç”¨æˆ·')
    
    # ä¸‰å¤§é¡¹æœ€ä½³è®°å½•
    squat_1rm = models.FloatField(null=True, blank=True, verbose_name='æ·±è¹²1RM(kg)')
    squat_1rm_date = models.DateField(null=True, blank=True, verbose_name='æ·±è¹²1RMæ—¥æœŸ')
    bench_press_1rm = models.FloatField(null=True, blank=True, verbose_name='å§æ¨1RM(kg)')
    bench_press_1rm_date = models.DateField(null=True, blank=True, verbose_name='å§æ¨1RMæ—¥æœŸ')
    deadlift_1rm = models.FloatField(null=True, blank=True, verbose_name='ç¡¬æ‹‰1RM(kg)')
    deadlift_1rm_date = models.DateField(null=True, blank=True, verbose_name='ç¡¬æ‹‰1RMæ—¥æœŸ')
    
    # æ€»é‡é‡
    total_1rm = models.FloatField(null=True, blank=True, verbose_name='ä¸‰å¤§é¡¹æ€»é‡é‡(kg)')
    
    # ä½“é‡ç›¸å…³
    bodyweight = models.FloatField(null=True, blank=True, verbose_name='è®°å½•æ—¶ä½“é‡(kg)')
    bodyweight_date = models.DateField(null=True, blank=True, verbose_name='ä½“é‡è®°å½•æ—¥æœŸ')
    
    # åŠ›é‡ç³»æ•°
    strength_coefficient = models.FloatField(null=True, blank=True, verbose_name='åŠ›é‡ç³»æ•°(æ€»é‡é‡/ä½“é‡)')
    
    # ç›®æ ‡è®¾å®š
    squat_goal = models.FloatField(null=True, blank=True, verbose_name='æ·±è¹²ç›®æ ‡(kg)')
    bench_press_goal = models.FloatField(null=True, blank=True, verbose_name='å§æ¨ç›®æ ‡(kg)')
    deadlift_goal = models.FloatField(null=True, blank=True, verbose_name='ç¡¬æ‹‰ç›®æ ‡(kg)')
    total_goal = models.FloatField(null=True, blank=True, verbose_name='æ€»é‡é‡ç›®æ ‡(kg)')
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_workouts = models.IntegerField(default=0, verbose_name='æ€»è®­ç»ƒæ¬¡æ•°')
    current_streak = models.IntegerField(default=0, verbose_name='å½“å‰è¿ç»­å¤©æ•°')
    longest_streak = models.IntegerField(default=0, verbose_name='æœ€é•¿è¿ç»­å¤©æ•°')
    total_duration = models.IntegerField(default=0, verbose_name='æ€»è®­ç»ƒæ—¶é•¿(åˆ†é’Ÿ)')
    
    # æ—¶é—´æˆ³
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        verbose_name = 'å¥èº«åŠ›é‡æ¡£æ¡ˆ'
        verbose_name_plural = 'å¥èº«åŠ›é‡æ¡£æ¡ˆ'
    
    def __str__(self):
        return f"{self.user.username} - åŠ›é‡æ¡£æ¡ˆ"
    
    def update_stats(self):
        """æ›´æ–°ç»Ÿè®¡æ•°æ®"""
        from datetime import datetime, timedelta
        
        # æ›´æ–°æ€»è®­ç»ƒæ¬¡æ•°
        self.total_workouts = ExerciseWeightRecord.objects.filter(user=self.user).count()
        
        # æ›´æ–°è¿ç»­å¤©æ•°
        records = ExerciseWeightRecord.objects.filter(user=self.user).order_by('-workout_date')
        if records.exists():
            current_streak = 0
            longest_streak = 0
            temp_streak = 0
            current_date = datetime.now().date()
            
            for i, record in enumerate(records):
                if i == 0:
                    if record.workout_date == current_date:
                        temp_streak = 1
                    else:
                        break
                else:
                    prev_record = records[i-1]
                    if (prev_record.workout_date - record.workout_date).days == 1:
                        temp_streak += 1
                    else:
                        break
            
            self.current_streak = temp_streak
            
            # è®¡ç®—æœ€é•¿è¿ç»­å¤©æ•°
            dates = list(records.values_list('workout_date', flat=True).distinct())
            if dates:
                dates.sort(reverse=True)
                temp_streak = 1
                longest_streak = 1
                
                for i in range(1, len(dates)):
                    if (dates[i-1] - dates[i]).days == 1:
                        temp_streak += 1
                        longest_streak = max(longest_streak, temp_streak)
                    else:
                        temp_streak = 1
                
                self.longest_streak = longest_streak
        
        self.save()
    
    def update_1rm_records(self):
        """æ›´æ–°1RMè®°å½• - ä¼˜åŒ–ç‰ˆæœ¬"""
        from django.db.models import Max, Q
        
        # ä½¿ç”¨å•æ¬¡æŸ¥è¯¢è·å–æ‰€æœ‰è¿åŠ¨ç±»å‹çš„æœ€ä½³è®°å½•
        best_records = ExerciseWeightRecord.objects.filter(
            user=self.user,
            exercise_type__in=['squat', 'bench_press', 'deadlift']
        ).values('exercise_type').annotate(
            max_weight=Max('weight'),
            latest_date=Max('workout_date')
        ).order_by('exercise_type')
        
        # æ‰¹é‡è·å–æœ€ä½³è®°å½•çš„è¯¦ç»†ä¿¡æ¯
        exercise_types = ['squat', 'bench_press', 'deadlift']
        for exercise_type in exercise_types:
            best_record = ExerciseWeightRecord.objects.filter(
                user=self.user,
                exercise_type=exercise_type
            ).order_by('-weight', '-workout_date').first()
            
            if best_record:
                setattr(self, f'{exercise_type}_1rm', best_record.get_estimated_1rm())
                setattr(self, f'{exercise_type}_1rm_date', best_record.workout_date)
        
        # æ›´æ–°æ€»é‡é‡
        if self.squat_1rm and self.bench_press_1rm and self.deadlift_1rm:
            self.total_1rm = self.squat_1rm + self.bench_press_1rm + self.deadlift_1rm
        
        # æ›´æ–°åŠ›é‡ç³»æ•°
        if self.total_1rm and self.bodyweight:
            self.strength_coefficient = round(self.total_1rm / self.bodyweight, 2)
        
        self.save()
    
    def get_strength_level(self):
        """è·å–åŠ›é‡ç­‰çº§"""
        if not self.total_1rm:
            return 'æœªè®°å½•'
        
        if self.total_1rm < 200:
            return 'åˆå­¦è€…'
        elif self.total_1rm < 400:
            return 'è¿›é˜¶è€…'
        elif self.total_1rm < 600:
            return 'ä¸­çº§è€…'
        elif self.total_1rm < 800:
            return 'é«˜çº§è€…'
        else:
            return 'ä¸“å®¶çº§'
    
    def get_progress_percentage(self, exercise_type):
        """è·å–è¿›åº¦ç™¾åˆ†æ¯”"""
        current = getattr(self, f'{exercise_type}_1rm', 0) or 0
        goal = getattr(self, f'{exercise_type}_goal', 0) or 0
        
        if goal == 0:
            return 0
        
        return min(round((current / goal) * 100, 1), 100)